نمایش کدهای دودویی که بعد از فرانک گری (Frank Gray) به نام کد گِرِی شناخته شد، یک سیستم از اعداد دودویی است که هر دو عدد متوالی فقط در یک بیت با هم اختلاف داشته باشند.
یکی از محققان آزمایشگاه بل (Bell) به نام فرانک گری اولین بار به‌طور رسمی کد گری را مورد استفاده قرار داد و این کد بعد از گری توسط افرادی که از آن استفاده می‌کردند کد گری نامگذاری شد.
کد گری قبل از آن که در مهندسی به کار رود در پازل‌های ریاضی به کار برده می‌شد، ریاضیدان فرانسوی Emile Boudat از کد گری در سال ۱۸۷۸در تلگراف استفاده کرد و برای این کارش مدال دریافت کرد.
کد گری یک دور همیلتونی در یک مکعب                         n                 {\displaystyle n}     بعدی                                    Q                        n                                     {\displaystyle Q_{n}}     تولید می‌کند که هر کدام از اعداد آن یک راس را نشان می‌دهد و نیز در الگوریتم‌های ژنتیکی از آن استفاده می‌شود و البته برچسب گذاری جدول کارنو از موارد دیگر استفاده آن است.
زمانی کد گری برای آدرس دهی حافظه در کامپیوتر استفاده می‌شود، کامپیوتر نیروی کمتری صرف یافتن آدرس‌ها می‌کند چون هر آدرس با قبلی فقط در یک بیت متفاوت است.
بعضی از دستگاه‌ها وضعیت دستگاه را با کدهای باینری نمایش می‌دهند، اگر این دستگاه‌ها از کد باینری عادی استفاده کند این دو وضعیت پشت سر هم خواهند بود
و مشکل کد باینری عادی این است که در حالت طبیعی خیلی بعید است که چند بیت همزمان تغییر کنند همان‌طور که در بالا نمایش داده شده‌است که در کد باینری عادی هر سه بیت همزمان تغییر کرده‌اند اما می‌توان اعداد را طوری در کنار هم قرار داد که فقط در یک بیت متفاوت باشند و تغییر زیادی نکنند مثل                        011         &#x2212;         001         &#x2212;         101         &#x2212;         100                 {\displaystyle 011-001-101-100}     پس کد باینری منعکس شده یا همان کد گری این مشکل را حل می‌کند زیرا که فقط یک بیت در آن‌ها تغییر می‌کند.
یک کد گری                         n                 {\displaystyle n}     بیتی را می‌توان به صورت بازگشتی تولید کرد، به این شکل که یک لیست                         n         &#x2212;         1                 {\displaystyle n-1}     بیتی داریم آن را وارونه می‌کنیم (خط افقی در شکل زیر مانند آینه عمل کند) و در انتهای لیست اصلی می‌چسبانیم و سپس در ابتدای لیست اول                         0                 {\displaystyle 0}     و در ابتدای لیست دوم                         1                 {\displaystyle 1}     قرار می‌دهیم مثلاً برای کد گری یک بیتی ،                         G         =                    0           ,           1                          {\displaystyle G={0,1}}     را داریم (البته می‌توان از کد گری                         0                 {\displaystyle 0}     بیتی هم استفاده کرد).                         n         =         0         ,         G         =                    0           ,           1                          {\displaystyle n=0,G={0,1}}    ، و بعد با آن کد گری                        1                 {\displaystyle 1}     بیتی را به صورت بازگشتی بسازیم و اکنون شبه کد آن را داریم.
۱ Let B[n:0] be the input array of bits in the usual binary representation, [0] being LSB ۲ Let G[n:0] be the output array of bits in Gray code ۳ G[n] = B[n] ۴ for i = n-1 downto 0 ۵ G[i] = B[i+1] XOR B[i]
۱ Let G[n:0] be the input array of bits in Gray code ۲ Let B[n:0] be the output array of bits in the usual binary representation ۳ B[n] = G[n] ۴ for i = n-1 downto 0 ۵ B[i] = B[i+1] XOR G[i]
سپس از سمت چپ شروع می‌کنیم و اولین عدد را همان‌طور که هست نوشته سپس دوتا دوتا عددها رو مقایسه می‌کنیم، اگر هردو یکسان باشند در این صورت به جای آن دو عدد صفر می‌گذاریم، در غیر این صورت: یعنی اگر یکی از عددها صفر و دیگری یک باشد، آن وقت به جای آن دو عدد یک را به جای آنها می‌نویسیم
۱ long inverseGray(long n) { ۲ long ish, ans, idiv; ۳ ish = ۱; ۴ ans = n; ۵ while(true) { ۶ idiv = ans&gt;&gt; ish; ۷ ans ^= idiv; ۸ if (idiv &lt;= ۱ || ish == ۳۲) ۹ return ans; ۱۰ ish &lt;&lt;= ۱; // double number of shifts next time}}
انواع مختلفی از کد گری وجود دارد که یی از این انواع مختلف کد گری n تایی است که به عنوان کد گری غیر دوتایی (۰و۱)هم شناخته می‌شود یعنی به غیر از ۰ و ۱ از اعداد دیگر هم استفاده می‌شود (همان‌طور که نام آن نشان می‌دهد) و در رمزگذاری هم از آن استفاده می‌شود. برای مثال یک کد گری سه تایی از بیت‌های {۰و۱و۲} استفاده می‌کند. کد گری سه تایی
،۰۰۰ ،۰۰۱ ،۰۰۲ ،۰۱۲ ،۰۱۱ ،۰۱۰ ،۰۲۰ ،۰۲۱ ،۰۲۲ ،۱۲۲ ،۱۲۱ ،۱۲۰ ،۱۱۰ ،۱۱۱ ،۱۱۲ ،۱۰۲ ،۱۰۱ ،۱۰۰ ،۲۰۰ ،۲۰۱ ،۲۰۲ ،۲۱۲ ،۲۱۱ ،۲۱۰ ،۲۲۰ ،۲۲۱ ،۲۲۲
یک کد گری (n,k)تایی یک کد گری n تایی است که دارای k بیت است مثلاً یک کد گری(۲و۳)برابر است با {۰۰، ۰۱، ۰۲، ۱۲، ۱۱، ۱۰، ۲۰، ۲۱، ۲۲} و اکنون الگوریتم ساخت کد گری (n,k) در C/java در زیر آمده‌است
int n[k+1]; // stores the maximum for each digit int g[k+1]; // stores the Gray code int u[k+1]; // stores +1 or -1 for each element int i, j; // initialize values for(i = ۰; i &lt;= k; i++) { g[i] = ۰; u[i] = ۱; n[i] = N; } // generate codes while(g[k] == ۰) { // at this point (g[۰],... ,g[k-1]) hold a subsequent element of the (N,k)-Gray code i = ۰; j = g[۰] + u[0]; while((j&gt;= n[i]) || (j &lt;۰)) { u[i] = -u[i]; i++; j = g[i] + u[i]; } g[i] = j; }
