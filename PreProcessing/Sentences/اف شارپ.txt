اف شارپ (به انگلیسی&#58; F Sharp) (به اختصار: #F) یک نمونهٔ عالی از زبان‌های تایپ قوی (سریع) و چند الگویی می‌باشد که از تکنیک‌های (یا الگوهای) برنامه‌نویسی تابعی، امری و شیءگرایی پشتیبانی می‌کند. از F# اغلب به عنوان یک زبان CLI کراس‌پلتفرم استفاده می‌شود اما از این زبان می‌توان برای تولید کدهای جاوا اسکریپت و کار با GPU استفاده کرد.
F# توسط بنیاد نرم‌افزاری F# توسعه پیدا کرده‌است که شامل: مایکروسافت و بقیه همکاران می‌باشد. متن‌باز بودن و کامپایلر کراس پلتفرم این امکان را به F# می‌دهد تا از آن برای تولید نرم‌افزارهای بنیادی، اصلی و انواع kernelها و … مورد استفاد قرار بگیرد. یکی دیگر از مزیت‌های این زبان پشتیبانی کامل Visual Studio از این زبان می‌باشد به گونه ای که از نسخه ۲۰۰۸ به بعد در تمامی نسخه‌های ویژوال استودیو از این زبان پشتیبانی کامل به عمل آمده که شامل:
F# is a strongly typed functional-first language that uses type inference. Types do not need to be explicitly declared by the programmer; they will be deduced by the compiler during compilation. F# also allows explicit type annotations and requires them in some situations.
F# is an expression-based language using eager evaluation. Every statement in F#, including if expressions, try expressions and loops, is a composable expression with a static type. Functions and expressions that do not return any value have a return type of unit. F# uses the let keyword for binding values to a name. For example:
New types are defined using the type keyword. For functional programming, F# provides tuple, record, discriminated union, list and option types. A tuple represents a collection of n values, where n ≥ 0. The value n is called the arity of the tuple. A 3-tuple would be represented as (A, B, C), where A, B and C are values of possibly different types. A tuple can be used to store values only when the number of values is known at design-time and stays constant throughout execution.
A record is a type where the data members are named, as in { Name:string; Age:int }. Records can be created as { Name="AB"; Age=42 }. The with keyword is used to create a copy of a record, as in { r with Name="CD" }, which creates a new record by copying r and changing the value of the Name field (assuming the record created in the last example was named r).
Values of the union type can correspond to either union case. The types of the values carried by each union case is included in the definition of each case.
The list type is an immutable linked list represented either using a head::tail notation (:: is the cons operator) or a shorthand as [item1; item2; item3]. An empty list is written []. The option type is a discriminated union type with choices Some(x) or None. F# types may be generic, implemented as generic .NET types.
F# supports lambda functions and closures. All functions in F# are first class values and are immutable. Functions can be curried. Being first-class values, functions can be passed as arguments to other functions. Like other functional programming languages, F# allows function composition using the &gt;&gt; and &lt;&lt; operators.
F# provides sequence expressions that define a sequence seq { ... }, list [...] or array [| ... |] through code that generates values. For example,
forms a sequence of squares of numbers from 0 to 14 by filtering out numbers from the range of numbers from 0 to 25. Sequences are generated on-demand (i.e. are lazily evaluated), while lists and arrays are evaluated eagerly.
F# uses تطبیق الگو to bind values to names. Pattern matching is also used when accessing discriminated unions - the union is value matched against pattern rules and a rule is selected when a match succeeds. F# also supports Active Patterns as a form of extensible pattern matching. It is used, for example, when multiple ways of matching on a type exist.
F# supports a general syntax for defining compositional computations called computation expressions. Sequence expressions, asynchronous computations and queries are particular kinds of computation expressions. Computation expressions are an implementation of the monad pattern.
F# object type definitions can be class, struct, interface, enum or delegate type definitions, corresponding to the definition forms found in the C#. For example, here is a class with a constructor taking a name and age, and declaring two properties.
The let! allows the rest of the async block to be defined as the delegate and passed as the callback function of an asynchronous operation. This solves the inversion of control problem. The async block is invoked using the Async.RunSynchronously function. Multiple async blocks are executed in parallel using the Async.Parallel function that takes a list of async objects (in the example, asynctask is an async object) and creates another async object to run the tasks in the lists in parallel. The resultant object is invoked using Async.RunSynchronously.
Parallel programming is also supported through the Array.Parallel functional programming operators in the F# standard library, direct use of the System.Threading.Tasks task programming model, the direct use of .NET thread pool and .NET threads and through dynamic translation of F# code to alternative parallel execution engines such as GPU code.
The F# type system supports units of measure checking for numbers. The units of measure feature integrates with F# type inference to require minimal type annotations in user code.
F# includes a feature for run-time meta-programming called quotations. A quotation expression evaluates to an abstract syntax representation of F# expressions. A definition labelled with the [&lt;ReflectedDefinition&gt;] attribute can also be accessed in its quotation form. F# quotations are used for various purposes including to compile F# code to جاوااسکریپت and GPU code.
F# 3.0 introduced a form of compile-time meta-programming through statically extensible type generation called F# type providers. F# type providers allow the F# compiler and tools to be extended with components that provide type information to the compiler on-demand at compile time. F# type providers have been used to give strongly typed access to connected information sources in a scalable way, including to the فری‌بیس knowledge graph.
F# supports a variation of the Actor programming model through the in-memory implementation of lightweight asynchronous agents. For example, the following code defines an agent and posts 2 messages:
The Visual F# tools from Microsoft include full IDE integration in Visual Studio. With the language service installed, Visual Studio can be used to create F# projects and the Visual Studio debugger used to debug F# code. In addition, the Visual F# tools comes with a Visual Studio-hosted REPL interactive console that can be used to execute F# code as it is being written.
F# is a central part of the WebSharper framework where F# code is executed as a .NET code on the server and as جاوااسکریپت code on the client-side.
In recent years, F# is placed as optimised alternative of C#, F#'s scripting ability and IL compitablility with all Microsoft products have made it popular amongst developers, many developers create solutions based on F# and expose the functionality using C# WCF Services.
A simple example that is often used to demonstrate the syntax of functional languages is the factorial function for non-negative 32-bit integers, here shown in F#:
