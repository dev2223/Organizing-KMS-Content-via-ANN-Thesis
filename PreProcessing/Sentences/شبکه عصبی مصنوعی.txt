شبکه‌های عصبی مصنوعی (Artificial Neural Networks - ANN) یا به زبان ساده‌تر شبکه‌های عصبی سیستم‌ها و روش‌های محاسباتی نوین برای یادگیری ماشینی، نمایش دانش و در انتها اعمال دانش به دست آمده در جهت بیش‌بینی پاسخ‌های خروجی از سامانه‌های پیچیده هستند. ایدهٔ اصلی این گونه شبکه‌ها تا حدودی الهام‌گرفته از شیوهٔ کارکرد سیستم عصبی زیستی برای پردازش داده‌ها و اطلاعات به منظور یادگیری و ایجاد دانش می‌باشد. عنصر کلیدی این ایده، ایجاد ساختارهایی جدید برای سامانهٔ پردازش اطلاعات است. 
این سیستم از شمار زیادی عناصر پردازشی فوق‌العاده بهم‌پیوسته با نام نورون تشکیل شده که برای حل یک مسئله با هم هماهنگ عمل می‌کنند و توسط سیناپس‌ها (ارتباطات الکترومغناطیسی) اطلاعات را منتقل می‌کنند. در این شبکه‌ها اگر یک سلول آسیب ببیند بقیه سلول‌ها می‌توانند نبود آن را جبران کرده، و نیز در بازسازی آن سهیم باشند. این شبکه‌ها قادر به یادگیری‌اند؛ مثلاً با اعمال سوزش به سلول‌های عصبی لامسه، سلول‌ها یادمی‌گیرند که به طرف جسم داغ نروند و با این الگوریتم سیستم می‌آموزد که خطای خود را اصلاح کند. یادگیری در این سیستم‌ها به صورت تطبیقی صورت می‌گیرد، یعنی با استفاده از مثال‌ها وزن سیناپس‌ها به گونه‌ای تغییر می‌کند که در صورت دادن ورودی‌های جدید، سیستم پاسخ درستی تولید کند.
فلسفهٔ اصلی شبکهٔ عصبی مصنوعی، مدل کردن ویژگی‌های پردازشی مغز انسان برای تقریب زدن روش‌های معمول محاسباتی با روش پردازش زیستی است. به بیان دیگر، شبکهٔ عصبی مصنوعی روشی است که دانش ارتباط بین چند مجموعهٔ داده را از طریق آموزش فراگرفته و برای استفاده در موارد مشابه ذخیره می‌کند. این پردازنده از دو جهت مشابه مغز انسان عمل می‌کند:
یک شبکهٔ عصبی مصنوعی، از سه لایهٔ ورودی، خروجی و پردازش تشکیل می‌شود. هر لایه شامل گروهی از سلول‌های عصبی (نورون) است که عموماً با کلیهٔ نورون‌های لایه‌های دیگر در ارتباط هستند، مگر این که کاربر ارتباط بین نورون‌ها را محدود کند؛ ولی نورون‌های هر لایه با سایر نورون‌های همان لایه، ارتباطی ندارند.
نورون کوچک‌ترین واحد پردازشگر اطلاعات است که اساس عملکرد شبکه‌های عصبی را تشکیل می‌دهد. یک شبکهٔ عصبی مجموعه‌ای از نورون‌هاست که با قرار گرفتن در لایه‌های مختلف، معماری خاصی را بر مبنای ارتباطات بین نورون‌ها در لایه‌های مختلف تشکیل می‌دهند. نورون می‌تواند یک تابع ریاضی غیرخطی باشد، در نتیجه یک شبکهٔ عصبی که از اجتماع این نورون‌ها تشکیل می‌شود، نیز می‌تواند یک سامانهٔ کاملاً پیچیده و غیرخطی باشد. در شبکهٔ عصبی هر نورون به‌طور مستقل عمل می‌کند و رفتار کلی شبکه، برآیند رفتار نورون‌های متعدد است. به عبارت دیگر، نورون‌ها در یک روند همکاری، یکدیگر را تصحیح می‌کنند.
با استفاده از دانش برنامه‌نویسی رایانه می‌توان ساختار داده‌ای طراحی کرد که همانند یک نورون عمل نماید. سپس با ایجاد شبکه‌ای از این نورون‌های مصنوعی به هم پیوسته، ایجاد یک الگوریتم آموزشی برای شبکه و اعمال این الگوریتم به شبکه آن را آموزش داد.
این شبکه‌ها برای تخمین و تقریب، کارایی بسیار بالایی از خود نشان داده‌اند. گستره کاربرد این مدل‌های ریاضی بر گرفته از عملکرد مغز انسان، بسیار وسیع می‌باشد که به عنوان چند نمونه کوچک می‌توان استفاده از این ابزار ریاضی در پردازش سیگنال‌های بیولوژیکی، مخابراتی و الکترونیکی تا کمک در نجوم و فضانوردی را نام برد.
یادگیری ماشینی با نظارت (supervised learning) به دنبال تابعی از میان یک سری توابع هست که تابع هزینه (loss function) داده‌ها را بهینه سازد. به عنوان مثال در مسئله رگرسیون تابع هزینه می‌تواند اختلاف بین پیش‌بینی و مقدار واقعی خروجی به توان دو باشد، یا در مسئله طبقه‌بندی ضرر منفی لگاریتم احتمال خروجی باشد. مشکلی که در یادگیری شبکه‌های عصبی وجود دارد این است که این مسئله بهینه‌سازی دیگر محدب (convex) نیست. ازین رو با مشکل کمینه‌های محلی روبرو هستیم. یکی از روش‌های متداول حل مسئله بهینه‌سازی در شبکه‌های عصبی بازگشت به عقب یا همان back propagation است. روش بازگشت به عقب گرادیانِ تابع هزینه را برای تمام وزن‌های شبکه عصبی محاسبه می‌کند و بعد از روش‌های گرادیان کاهشی (gradient descent) برای پیدا کردن مجموعه وزن‌های بهینه استفاده می‌کند. روش‌های گرادیان کاهشی سعی می‌کنند به صورت متناوب در خلاف جهت گرادیان حرکت کنند و با این کار تابع هزینه را به حداقل برسانند. پیدا کردن گرادیانِ لایه آخر ساده است و با استفاده از مشتق جزئی بدست می‌آید. گرادیانِ لایه‌های میانی اما به صورت مستقیم بدست نمی‌آید و باید از روش‌هایی مانند قاعده زنجیری در مشتق‌گیری استفاده کرد. روش بازگشت به عقب از قاعده زنجیری برای محاسبه گرادیان‌ها استفاده می‌کند و همان‌طور که در پایین خواهیم دید، این روش به صورت متناوب گرادیان‌ها را از بالاترین لایه شروع کرده آن‌ها را در لایه‌های پایینتر «پخش» می‌کند.
برای سلول عصبی                         c                 {\displaystyle c}     ورودیی که از سلول عصبی                         p                 {\displaystyle p}     به این سلول وارد می‌شود را با                                    b                        p             c                                     {\displaystyle b_{pc}}     نشان می‌دهیم. وزن این ورودی                                    w                        p             c                                     {\displaystyle w_{pc}}     است و مجموع ضرب ورودی‌ها با وزنهایشان را با                                    a                        c                                     {\displaystyle a_{c}}     نمایش می‌دهیم، به این معنی که                                    a                        c                             =                    &#x2211;                        p                                        w                        p             c                             &#x00D7;                    b                        p             c                                     {\displaystyle a_{c}=\sum _{p}w_{pc}\times b_{pc}}    . حال باید بر روی                                    a                        c                                     {\displaystyle a_{c}}     تابعی غیر خطی اعمال کنیم این تابع را                                    &#x03B8;                        c                                     {\displaystyle \theta _{c}}     می‌نامیم و خروجی آن را با                                    b                        c                                     {\displaystyle b_{c}}     نمایش می‌دهیم یعنی                                    b                        c                             =                    &#x03B8;                        c                             (                    a                        c                             )                 {\displaystyle b_{c}=\theta _{c}(a_{c})}    . به همین شکل خروجیی که از سلول عصبی                         c                 {\displaystyle c}     خارج شده و به سلول                         n                 {\displaystyle n}     وارد می‌شود را با                                    b                        c             n                                     {\displaystyle b_{cn}}     نمایش می‌دهیم و وزن آن را                                    w                        c             n                                     {\displaystyle w_{cn}}     می‌نامیم. حال تمام وزن‌های این شبکه عصبی را در مجموعه‌ای به اسم                         W                 {\displaystyle W}     می‌گنجانیم، هدف یادگیری این وزنهاست. اگر ورودی ما                         x                 {\displaystyle x}     باشد و خروجی                         y                 {\displaystyle y}     و خروجی شبکه عصبی ما                                    h                        W                             (         x         )                 {\displaystyle h_{W}(x)}    ، هدف پیدا کردن                         W                 {\displaystyle W}     است به قسمی که برای تمام داده‌ها                         y                 {\displaystyle y}     و                                    h                        W                             (         x         )                 {\displaystyle h_{W}(x)}     به هم خیلی نزدیک شوند. به عبارت دیگر هدف کوچک کردن یک تابع هزینه بر روی تمام داده هاست، اگر داده‌ها را با                         (                    x                        1                             ,                    y                        1                             )         ,         &#x22EF;         ,         (                    x                        n                             ,                    y                        n                             )                 {\displaystyle (x_{1},y_{1}),\cdots ,(x_{n},y_{n})}     و تابع هزینه را با                         l                 {\displaystyle l}     نشان دهیم هدف کمینه کردن تابع پایین است:
                        Q         (         W         )         =                    &#x2211;                        i             =             1                                   n                             l                    (                                       h                                W                                         (                            x                                i                                         )             ,                                                      y                                i                                                  )                          {\displaystyle Q(W)=\sum _{i=1}^{n}l\left(h_{W}(x_{i}),\,\,y_{i}\right)}    
به عنوان مثال اگر مسئله رگرسیون است برای                         l                 {\displaystyle l}     می‌توانیم خطای مربعات را در نظر بگیریم و اگر مسئله دسته‌بندی است برای                         l                 {\displaystyle l}     می‌شود منفی لگاریتم درست نمایی را استفاده کرد.
برای به‌دست آوردن کمینه                         Q         (         W         )                 {\displaystyle Q(W)}     باید از روش گرادیان کاهشی استفاده کرد، به این معنی که گرادیان تابع را حساب کرده، کمی در خلاف جهت آن حرکت کرده و این کار را آنقدر ادامه داد تا تابع هزینه خیلی کوچک شود. روش بازگشت به عقب در واقع روشی برای پیدا کردن گرادیان تابع                         Q         (         W         )                 {\displaystyle Q(W)}     است.
حال فرض کنیم می‌خواهیم گرادیان تابع                         Q         (         W         )                 {\displaystyle Q(W)}     را نسبت به وزن                                    w                        p             c                                     {\displaystyle w_{pc}}     به‌دست بیاوریم. برای این کار نیاز به قاعده زنجیری در مشتق‌گیری داریم. قاعده زنجیری به این شکل کار می‌کند: اگر تابعی داشته باشیم به اسم                         f                 {\displaystyle f}     که وابسته به سه ورودی                         u                 {\displaystyle u}    ،                         v                 {\displaystyle v}     و                         w                 {\displaystyle w}     باشد و هرکدام از این سه ورودی به نوبه خود وابسته به                         t                 {\displaystyle t}     باشند، مشتق                         f                 {\displaystyle f}     به                         t                 {\displaystyle t}     به این شکل محاسبه می‌شود:
                                                               &#x2202;               f                                (                                    u                   (                   t                   )                   ,                   v                   (                   t                   )                   ,                   w                   (                   t                   )                                  )                                                        &#x2202;               t                                          =                                                &#x2202;               f                                         &#x2202;               u                                                                                 &#x2202;               u                                         &#x2202;               t                                          +                                                &#x2202;               f                                         &#x2202;               v                                                                                 &#x2202;               v                                         &#x2202;               t                                          +                                                &#x2202;               f                                         &#x2202;               w                                                                                 &#x2202;               w                                         &#x2202;               t                                                  {\displaystyle {\frac {\partial f\left(u(t),v(t),w(t)\right)}{\partial t}}={\frac {\partial f}{\partial u}}{\frac {\partial u}{\partial t}}+{\frac {\partial f}{\partial v}}{\frac {\partial v}{\partial t}}+{\frac {\partial f}{\partial w}}{\frac {\partial w}{\partial t}}}    
                                   &#x03B4;                        c                             =                                                &#x2202;               Q                                         &#x2202;                                a                                    c                                                                                  {\displaystyle \delta _{c}={\frac {\partial Q}{\partial a_{c}}}}    
                                   a                        c                             =                    &#x2211;                        p                                        w                        p             c                             &#x00D7;                    b                        p             c                                     {\displaystyle a_{c}=\sum _{p}w_{pc}\times b_{pc}}    
                                   b                        c                             =                    &#x03B8;                        c                             (                    a                        c                             )                 {\displaystyle b_{c}=\theta _{c}(a_{c})}    
                                   &#x03B4;                        c                             =                                                &#x2202;               Q                                         &#x2202;                                a                                    c                                                                          =                                                &#x2202;               Q                                         &#x2202;                                b                                    c                                                                                                                 &#x2202;                                b                                    c                                                                         &#x2202;                                a                                    c                                                                          =                                                &#x2202;               Q                                         &#x2202;                                b                                    c                                                                          &#x00D7;                                                                 &#x03B8;                 &#x00B4;                                                               c                             (                    a                        c                             )         =                    (                                       &#x2211;                                n                                                                                            &#x2202;                   Q                                                     &#x2202;                                        a                                            n                                                                                                                                                     &#x2202;                                        a                                            n                                                                                             &#x2202;                                        b                                            c                                                                                                           )                  &#x00D7;                                                                 &#x03B8;                 &#x00B4;                                                               c                             (                    a                        c                             )         =                    (                                       &#x2211;                                n                                                        w                                c                 n                                                        &#x03B4;                                n                                                  )                  &#x00D7;                                                                 &#x03B8;                 &#x00B4;                                                               c                             (                    a                        c                             )                 {\displaystyle \delta _{c}={\frac {\partial Q}{\partial a_{c}}}={\frac {\partial Q}{\partial b_{c}}}{\frac {\partial b_{c}}{\partial a_{c}}}={\frac {\partial Q}{\partial b_{c}}}\times {\acute {\theta }}_{c}(a_{c})=\left(\sum _{n}{\frac {\partial Q}{\partial a_{n}}}{\frac {\partial a_{n}}{\partial b_{c}}}\right)\times {\acute {\theta }}_{c}(a_{c})=\left(\sum _{n}w_{cn}\delta _{n}\right)\times {\acute {\theta }}_{c}(a_{c})}    
                                                               &#x2202;               Q                                         &#x2202;                                w                                    p                   c                                                                          =                                                &#x2202;               Q                                         &#x2202;                                a                                    c                                                                                                                 &#x2202;                                a                                    c                                                                         &#x2202;                                w                                    p                   c                                                                          =                    &#x03B4;                        c                                        b                        p                                     {\displaystyle {\frac {\partial Q}{\partial w_{pc}}}={\frac {\partial Q}{\partial a_{c}}}{\frac {\partial a_{c}}{\partial w_{pc}}}=\delta _{c}b_{p}}    
همان‌طور که در خط پیشین دیدیم برای به‌دست آوردن گرادیان نسبت به                                    w                        p             c                                     {\displaystyle w_{pc}}     به دو مقدار نیاز داریم ورودی به سلول عصبی                         c                 {\displaystyle c}     از سلول عصبی                         p                 {\displaystyle p}     که همان                                    b                        p                                     {\displaystyle b_{p}}     است و راحت به‌دست می‌آید و                                    &#x03B4;                        c                                     {\displaystyle \delta _{c}}     که از روش بازگشتی به‌دست می‌آید و بستگی به                         &#x03B4;                 {\displaystyle \delta }    هایی لایه بعد دارد که سلول                         c                 {\displaystyle c}    به آن‌ها وصل است، به‌طور دقیق‌تر                                    &#x03B4;                        c                             =                    (                                       &#x2211;                                n                                                        w                                c                 n                                                        &#x03B4;                                n                                                  )                  &#x00D7;                                                                 &#x03B8;                 &#x00B4;                                                               c                             (                    a                        c                             )                 {\displaystyle \delta _{c}=\left(\sum _{n}w_{cn}\delta _{n}\right)\times {\acute {\theta }}_{c}(a_{c})}    .
روش بازگشتی برای به‌دست آوردن                         &#x03B4;                 {\displaystyle \delta }    ها به این شکل کار می‌کند که ابتدا                         &#x03B4;                 {\displaystyle \delta }     را برای سلول‌های لایه خروجی حساب می‌کنیم، و بعد لایه‌ها را به نوبت پایین می‌آئیم و برای هر سلول                         &#x03B4;                 {\displaystyle \delta }     آن را با ترکیت                         &#x03B4;                 {\displaystyle \delta }    های لایه‌های بالایی آن طبق فرمول حساب می‌کنیم. محاسبه کردن                         &#x03B4;                 {\displaystyle \delta }     برای لایه خروجی آسان است و مستقیماً با مشتق گرفتن از                         Q                 {\displaystyle Q}     به‌دست می‌آید.
از قرن نوزدهم به‌طور همزمان اما جداگانه، از سویی نوروفیزیولوژیست‌ها سعی کردند سیستم یادگیری و تجزیه و تحلیل مغز را کشف کنند، و از سوی دیگر ریاضیدانان تلاش کردند مدل ریاضی ای بسازند که قابلیت فراگیری و تجزیه و تحلیل عمومی مسائل را دارا باشد. اولین کوشش‌ها در شبیه‌سازی با استفاده از یک مدل منطقی در اوایل دههٔ ۱۹۴۰ توسط وارن مک‌کالک و والتر پیتز انجام شد که امروزه بلوک اصلی سازنده اکثر شبکه‌های عصبی مصنوعی است. عملکرد این مدل مبتنی بر جمع ورودی‌ها و ایجاد خروجی با استفاده از شبکه‌ای از نورون‌ها است. اگر حاصل جمع ورودی‌ها از مقدار آستانه بیشتر باشد، اصطلاحاً نورون برانگیخته می‌شود. نتیجه این مدل اجرای ترکیبی از توابع منطقی بود.
در سال ۱۹۴۹ دونالد هب قانون یادگیری را برای شبکه‌های عصبی طراحی کرد. در سال ۱۹۵۸ شبکه پرسپترون توسط روزنبلات معرفی گردید. این شبکه نظیر واحدهای مدل شده قبلی بود. پرسپترون دارای سه لایه است که شامل لایهٔ ورودی، لایهٔ خروجی و لایهٔ میانی می‌شود. این سیستم می‌تواند یاد بگیرد که با روشی تکرارشونده وزن‌ها را به گونه‌ای تنظیم کند که شبکه توان بازتولید جفت‌های ورودی و خروجی را داشته‌باشد. روش دیگر، مدل خطی تطبیقی نورون است که در سال ۱۹۶۰ توسط برنارد ویدرو و مارسیان هاف در دانشگاه استنفورد) به وجود آمد که اولین شبکه‌های عصبی به کار گرفته شده در مسائل واقعی بودند. آدالاین یک دستگاه الکترونیکی بود که از اجزای ساده‌ای تشکیل شده بود، روشی که برای آموزش استفاده می‌شد با پرسپترون فرق داشت.
در سال ۱۹۶۹ میسکی و پاپرت کتابی نوشتند که محدودیت‌های سیستم‌های تک لایه و چند لایه پرسپترون را تشریح کردند. نتیجه این کتاب پیش داوری و قطع سرمایه‌گذاری برای تحقیقات در زمینه شبیه‌سازی شبکه‌های عصبی بود. آن‌ها با طرح اینکه طرح پرسپترون قادر به حل هیچ مسئله جالبی نمی‌باشد، تحقیقات در این زمینه را برای مدت چندین سال متوقف کردند.
با وجود این‌که اشتیاق عمومی و سرمایه‌گذاری‌های موجود به حداقل خود رسیده بود، برخی محققان تحقیقات خود را برای ساخت ماشین‌هایی که توانایی حل مسائلی از قبیل تشخیص الگو را داشته باشند، ادامه دادند. از جمله گراسبگ که شبکه‌ای تحت عنوان Avalanch را برای تشخیص صحبت پیوسته و کنترل دست ربات مطرح کرد. همچنین او با همکاری کارپنتر شبکه‌های نظریه تشدید انطباقی را بنا نهادند که با مدل‌های طبیعی تفاوت داشت. اندرسون و کوهونن نیز از اشخاصی بودند که تکنیک‌هایی برای یادگیری ایجاد کردند. ورباس در سال ۱۹۷۴ شیوه آموزش پس انتشار خطا را ایجاد کرد که یک شبکه پرسپترون چندلایه البته با قوانین نیرومندتر آموزشی بود.
پیشرفت‌هایی که در سال ۱۹۷۰ تا ۱۹۸۰ به‌دست آمد، برای جلب توجه به شبکه‌های عصبی بسیار مهم بود. برخی فاکتورها نیز در تشدید این مسئله دخالت داشتند، از جمله کتاب‌ها و کنفرانس‌های وسیعی که برای مردم در رشته‌های متنوع ارائه شد. امروز نیز تحولات زیادی در تکنولوژی ANN ایجاد شده‌است.
