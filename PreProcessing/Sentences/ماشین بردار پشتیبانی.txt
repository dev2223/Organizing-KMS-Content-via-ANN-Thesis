این روش از جملهٔ روش‌های نسبتاً جدیدی است که در سال‌های اخیر کارایی خوبی نسبت به روش‌های قدیمی‌تر برای طبقه‌بندی نشان داده‌است. مبنای کاری دسته‌بندی کنندهٔ SVM دسته‌بندی خطی داده‌ها است و در تقسیم خطی داده‌ها سعی می‌کنیم خطی را انتخاب کنیم که حاشیه اطمینان بیشتری داشته باشد. حل معادله پیدا کردن خط بهینه برای داده‌ها به وسیله روش‌های QP که روش‌های شناخته شده‌ای در حل مسائل محدودیت‌دار هستند صورت می‌گیرد. قبل از تقسیمِ خطی برای اینکه ماشین بتواند داده‌های با پیچیدگی بالا را دسته‌بندی کند داده‌ها را به وسیلهٔ تابعِ phi به فضای با ابعاد خیلی بالاتر می‌بریم. برای اینکه بتوانیم مسئله ابعاد خیلی بالا را با استفاده از این روش‌ها حل کنیم از قضیه دوگانی لاگرانژ برای تبدیلِ مسئلهٔ مینیمم‌سازی مورد نظر به فرم دوگانی آن که در آن به جای تابع پیچیدهٔ phi که ما را به فضایی با ابعاد بالا می‌برد، تابعِ ساده‌تری به نامِ تابع هسته که ضرب برداری تابع phi است ظاهر می‌شود استفاده می‌کنیم. از توابع هسته مختلفی از جمله هسته‌های نمایی، چندجمله‌ای و سیگموید می‌توان استفاده نمود.
الگوریتم SVM، جزو الگوریتم‌های تشخیص الگو دسته‌بندی می‌شود. از الگوریتم SVM، در هر جایی که نیاز به تشخیص الگو یا دسته‌بندی اشیا در کلاس‌های خاص باشد می‌توان استفاده کرد. در ادامه به کاربردهای این الگوریتم به صورت موردی اشاره می‌شود:
سیستم آنالیز ریسک، کنترل هواپیما بدون خلبان، ردیابی انحراف هواپیما، شبیه‌سازی مسیر، سیستم راهنمایی اتوماتیک اتومبیل، سیستم‌های بازرسی کیفیت، آنالیز کیفیت جوشکاری، پیش‌بینی کیفیت، آنالیز کیفیت کامپیوتر، آنالیز عملیاتهای آسیاب، آنالیز طراحی محصول شیمیایی، آنالیز نگهداری ماشین، پیشنهاد پروژه، مدیریت و برنامه‌ریزی، کنترل سیستم فرایند شیمیایی و دینامیکی، طراحی اعضای مصنوعی، بهینه‌سازی زمان پیوند اعضا، کاهش هزینه بیمارستان، بهبود کیفیت بیمارستان، آزمایش اتاق اورژانس، اکتشاف روغن و گاز، کنترل مسیر در دستگاه‌های خودکار، ربات، جراثقال، سیستم‌های بصری، تشخیص صدا، اختصار سخن، کلاسه بندی صوتی، آنالیز بازار، سیستم‌های مشاوره‌ای محاسبه هزینه موجودی، اختصار اطلاعات و تصاویر، خدمات اطلاعاتی اتوماتیک، مترجم لحظه‌ای زبان، سیستم‌های پردازش وجه مشتری، سیستم‌های تشخیص ترمز کامیون، زمانبندی وسیله نقلیه، سیستم‌های مسیریابی، کلاسه بندی نمودارهای مشتری/بازار، تشخیص دارو، بازبینی امضا، تخمین ریسک وام، شناسایی طیفی، ارزیابی سرمایه، کلاسه بندی انواع سلول‌ها، میکروب‌ها و نمونه‌ها، پیش‌بینی فروش‌های آینده، پیش‌بینی نیازهای محصول، پیش‌بینی وضعیت بازار، پیش‌بینی شاخص‌های اقتصادی، پیش‌بینی ملزومات انرژی، پیش‌بینی واکنش‌های دارویی، پیش‌بینی بازتاب محصولات شیمیایی، پیش‌بینی هوا، پیش‌بینی محصول، پیش‌بینی ریسک محیطی، پیش‌بینی جداول داوری، مدل کردن کنترل فرایند، آنالیز فعالیت گارانتی، بازرسی اسناد، تشخیص هدف، تشخیص چهره، انواع جدید سنسورها، دستگاه کاشف زیر دریایی به وسیلهٔ امواج صوتی، رادار، پردازش سیگنال‌های تصویری شامل مقایسه اطلاعات، پیگیری هدف، هدایت جنگ‌افزارها، تعیین قیمت وضعیت فعلی، جلوگیری از پارازیت، شناسایی تصویر /سیگنال، چیدمان یک مدار کامل، بینایی ماشین، مدل کردن غیر خطی، ترکیب صدا، کنترل فرایند ساخت، آنالیز مالی، پیش‌بینی فرایندهای تولید، ارزیابی بکار گیری یک سیاست، بهینه‌سازی محصول، تشخیص ماشین و فرایند، مدل کردن کنترل سیستم‌ها، مدل کردن ساختارهای شیمیایی، مدل کردن سیستم‌های دینامیکی، مدل کردن سیگنال تراکم، مدل کردن قالب‌سازی پلاستیکی، مدیریت قراردادهای سهام، مدیریت وجوه بیمه، دیریت سهام، تصویب چک بانکی، اکتشاف تقلب در کارت اعتباری، ثبت نسیه، بازبینی امضا از چکها، پیش‌بینی ارزش نسیه، مدیریت ریسک رهن، تشخیص حروف و اعدا، تشخیص بیماری و…
ماتریس الگو را آماده می‌کنیم. تابع کرنلی را برای استفاده انتخاب می‌کنیم. پارامتر تابع کرنل و مقدار C را انتخاب می‌کنیم. برای محاسبهٔ مقادیرα_i الگوریتم آموزشی را با استفاده از حل‌کننده‌های QP اجرا می‌کنیم. داده‌های جدید با استفاده از مقادیرα_i و بردارهای پشتیبان می‌توانند دسته‌بندی شوند.
آموزش نسبتاً ساده است. برخلاف شبکه‌های عصبی در ماکزیمم‌های محلی گیر نمی‌افتد. برای داده‌های با ابعاد بالا تقریباً خوب جواب می‌دهد. مصالحه بین پیچیدگی دسته‌بندی‌کننده و میزان خطا به‌طور واضح کنترل می‌شود. به یک تابع کرنل خوب و انتخاب پارامتر C نیاز دارد.
ما مجموعه داده‌های آزمایش                                                 D                                     {\displaystyle {\mathcal {D}}}     شامل n عضو (نقطه) را در اختیار داریم که به صورت زیر تعریف می‌شود:
جایی که مقدار                         y                 {\displaystyle y}     برابر                         1                 {\displaystyle 1}     یا                          &#x2212;         1                 {\displaystyle -1}     و هر                                                 x                                   i                                     {\displaystyle \mathbf {x} _{i}}     یک بردار حقیقی                         p                 {\displaystyle p}    -بعدی است. هدف پیدا کردن ابرصفحه جداکننده با بیشترین فاصله از نقاط حاشیه‌ای است که نقاط با                                    y                        i                             =         1                 {\displaystyle y_{i}=1}     را از نقاط با                                    y                        i                             =         &#x2212;         1                 {\displaystyle y_{i}=-1}     جدا کند. هر ابر صفحه می‌تواند به صورت مجموعه‌ای از نقاط                                     x                          {\displaystyle \mathbf {x} }     که شرط زیر را ارضا می‌کنند نوشته شود:
                                   w                  &#x22C5;                    x                  &#x2212;         b         =         0         ,                          {\displaystyle \mathbf {w} \cdot \mathbf {x} -b=0,\,}    
جایی که. علامت ضرب است.                                                 w                                     {\displaystyle {\mathbf {w} }}     بردار نرمال است، که به ابرصفحه عمود است. ما می‌خواهیم                                                 w                                     {\displaystyle {\mathbf {w} }}     و                                                 b                                     {\displaystyle {\mathbf {b} }}     را طوری انتخاب کنیم که بیشترین فاصله بین ابر صفحه‌های موازی که داده‌ها را از هم جدا می‌کنند، ایجاد شود. این ابرصفحه‌ها با استفاده از رابطه زیر توصیف می‌شوند.
اگر داده‌های آموزشی جدایی پذیر خطی باشند، ما می‌توانیم دو ابر صفحه در حاشیه نقاط به‌طوری‌که هیچ نقطه مشترکی نداشته باشند، در نظر بگیریم و سپس سعی کنیم، فاصله آن‌ها را، حداکثر کنیم. با استفاده از هندسه، فاصله این دو صفحه                                                                2                                &#x2016;                                    w                                  &#x2016;                                                                 {\displaystyle {\tfrac {2}{\|\mathbf {w} \|}}}     است؛ بنابراین ما باید                         &#x2016;                    w                  &#x2016;                 {\displaystyle \|\mathbf {w} \|}     را مینیمم کنیم. برای اینکه از ورود نقاط به حاشیه جلوگیری کنیم، شرایط زیر را اضافه می‌کنیم: برای هر                         i                 {\displaystyle i}    
مسئله بهینه‌سازی مشاهده شده در قسمت قبل، مسئله سختی، برای حل کردن است، زیرا به                         &#x2016;                    w                  &#x2016;                 {\displaystyle \|\mathbf {w} \|}     وابسته است (نرم                                    w                          {\displaystyle \mathbf {w} }     یا اندازه طول بردار). خوشبختانه می‌توانیم، بدون تغییر در مسئله                         &#x2016;                    w                  &#x2016;                 {\displaystyle \|\mathbf {w} \|}     را با                                                               1               2                                          &#x2016;                    w                             &#x2016;                        2                                     {\displaystyle {\tfrac {1}{2}}\|\mathbf {w} \|^{2}}     جانشین کنیم (عبارت ½ برای آسودگی در محاسبات ریاضی آمده). این یک مسئله بهینه‌سازی (OP)برنامه‌ریزی غیرخطی(QP) است. به‌طور واضح تر:
                                                                                                   min                                        (                     w                     ,                     b                     )                                                                                             1                     2                                                     &#x2016;                                    w                                                     &#x2016;                                        2                                                                                                                                &#xA0;s.t.&#xA0;                                  &#x2200;                                  1                 &#x2264;                 i                 &#x2264;                 n                                                                                                                                        y                                                i                                                                 (                                            w                                          &#x22C5;                                                                     x                                                    i                                                                                          &#x2212;                     b                     )                     &#x2265;                     1.                                                                                                                          {\displaystyle {\begin{aligned}\min _{(w,b)}{\frac {1}{2}}\|\mathbf {w} \|^{2}\\{\text{ s.t. }}\forall \,1\leq i\leq n\\{\displaystyle y_{i}(\mathbf {w} \cdot \mathbf {x_{i}} -b)\geq 1.\,}\end{aligned}}}    
                                   &#x03B1;                        i                                     {\displaystyle \alpha _{i}}    :
اما فرمول فوق اشتباه است. فرض کنید ما بتوانیم خانواده‌ای از ابر صفحات که نقاط را تقسیم می‌کنند پیدا کنیم. پس همه                                    y                        i                             (                    w                  &#x22C5;                                 x                            i                                          &#x2212;         b         )         &#x2212;         1         &#x2265;         0                 {\displaystyle y_{i}(\mathbf {w} \cdot \mathbf {x_{i}} -b)-1\geq 0}     . بنابراین ما می‌توانیم مینیمم را با فرستادن همه                                    &#x03B1;                        i                                     {\displaystyle \alpha _{i}}     به                        +         &#x221E;                 {\displaystyle +\infty }     پیدا کنیم. با این حال شرط پیش گفته می‌تواند به صورت پایین بیان شود:
ما به دنبال نقاط saddle می‌گردیم. حالا می‌توان این مسئله را به کمک برنامه‌ریزی غیرخطی استاندارد حل کرد. جواب می‌تواند به صورت ترکیب خطی از بردارهای آموزشی بیان شود:
تنها چند                                   &#x03B1;                        i                                     {\displaystyle \alpha _{i}}     بزرگتر از صفر خواهد بود.                                                x                            i                                                  {\displaystyle \mathbf {x_{i}} }     متناظر، دقیقاً همان بردار پشتیبان خواهد بود و به شرط را ارضا خواهد کرد. از این می‌توان نتیجه گرفت که بردارهای پشتیبان شرط زیر را نیز ارضا می‌کنند:
                                   y                        i                             (                    w                  &#x22C5;                                 x                            i                                          &#x2212;         b         )         =         1                 {\displaystyle y_{i}(\mathbf {w} \cdot \mathbf {x_{i}} -b)=1}    
که اجازه می‌دهد مقدار b تعریف شود. در عمل الگوریتم مقاوم تر خواهد بود اگر از تمام                                    N                        S             V                                     {\displaystyle N_{SV}}     بردار پشتیبان میانگین گرفته شود:
استفاده از این واقعیت که                         &#x2016;                    w                             &#x2016;                        2                             =         w         &#x22C5;         w                 {\displaystyle \|\mathbf {w} \|^{2}=w\cdot w}     و جانشینی                                    w                  =                    &#x2211;                        i             =             1                                   n                                                     &#x03B1;                            i                                                y                            i                                                               x                                i                                                                 {\displaystyle \mathbf {w} =\sum _{i=1}^{n}{\alpha _{i}y_{i}\mathbf {x_{i}} }}     می‌توان نشان داد که دوگان SVM به مسئله بهینه‌سازی زیر ساده می‌شود:
در اینجا هسته به صورت                         k         (                                 x                                   i                             ,                                 x                                   j                             )         =                                 x                                   i                             &#x22C5;                                 x                                   j                                     {\displaystyle k(\mathbf {x} _{i},\mathbf {x} _{j})=\mathbf {x} _{i}\cdot \mathbf {x} _{j}}     تعریف می‌شود. عبارت                         &#x03B1;                 {\displaystyle \alpha }     تشکیل یک دوگان برای بردار وزن‌ها مجموعه آموزشی می‌دهد:
SVM اساساً یک جداکننده است. در بخش قبلی پایه‌های تئوری ماشین‌های بردار پشتیبان برای دسته‌بندی دو کلاس تشریح شد. یک تشخیص الگوی چند کلاسی می‌تواند به وسیلهٔ ترکیب ماشین‌های بردار پشیبان دو کلاسی حاصل شود. به‌طور معمول دو دید برای این هدف وجود دارد. یکی از آن‌ها استراتژی "یک در مقابل همه " برای دسته‌بندی هر جفت کلاس و کلاس‌های باقی‌مانده‌است. دیگر استراتژی "یک در مقابل یک" برای دسته‌بندی هر جفت است. در شرایطی که دسته‌بندی اول به دسته‌بندی مبهم منجر می‌شود. برای مسائل چند کلاسی٬رهیافت کلی کاهش مسئلهٔ چند کلاسی به چندین مسئله دودویی است. هریک از مسائل با یک جداکننده دودویی حل می‌شود. سپس خروجی جداکننده‌های دودویی SVM با هم ترکیب شده و به این ترتیب مسئله چند کلاس حل می‌شود.
ابرصفحه جداکننده بهینه اولین بار توسط وپنیک در سال ۱۹۶۳ ارائه شد که یک دسته‌کننده خطی بود. در سال ۱۹۹۲، Bernhard Boser, Isabelle Guyon و وپنیک راهی را برای ایجاد دسته‌بند غیرخطی، با استفاده قرار دادن هسته برای پیدا کردن ابرصفحه با بیشترین حاشیه، پیشنهاد دادند. الگوریتم پیشنهادی ظاهراً مشابه است، به جز آنکه تمام ضرب‌های نقطه‌ای با یک تابع هسته غیرخطی جایگزین شداند. این خصوصیت اجازه می‌دهد، الگوریتم، برای ابرصفحه با بیشترین حاشیه در یک فضای ویژگی تغییرشکل داده، مناسب باشد. ممکن است، تغییرشکل غیرخطی باشد و فضای تغییر یافته، دارای ابعاد بالاتری باشد. به هر حال دسته‌بندی‌کننده، یک ابرصفحه در فضای ویژگی با ابعاد بالا است، که ممکن است در فضای ورودی نیز غیرخطی باشد.
اگر از هسته با تابع گوسین استفاده شود، فضای ویژگی متناظر، یک فضای هیلبرت نامتناهی است. دسته‌کنندهٔ بیشترین حاشیه، خوش ترتیب است، بنابراین ابعاد نامتناهی، نتیجه را خراب نمی‌کند. هسته‌های متداول به صورت زیر هستند:
هسته با انتقال                         &#x03C6;         (                                 x                            i                                          )                 {\displaystyle \varphi (\mathbf {x_{i}} )}     با تساوی                         k         (                                 x                            i                                          ,                                 x                            j                                          )         =         &#x03C6;         (                                 x                            i                                          )         &#x22C5;         &#x03C6;         (                                 x                            j                                          )                 {\displaystyle k(\mathbf {x_{i}} ,\mathbf {x_{j}} )=\varphi (\mathbf {x_{i}} )\cdot \varphi (\mathbf {x_{j}} )}     در ارتباط است. همچنین مقدار wدر فضای انتقال یافته برابر                                                 w                      =                        &#x2211;                            i                                                &#x03B1;                            i                                                y                            i                                   &#x03C6;           (                                       x                                         i                                   )           .                          {\displaystyle \textstyle \mathbf {w} =\sum _{i}\alpha _{i}y_{i}\varphi (\mathbf {x} _{i}).}     است. ضرب نقطه‌ای با w می‌تواند توسط هسته محاسبه شود یعنی                                                 w                      &#x22C5;           &#x03C6;           (                        x                      )           =                        &#x2211;                            i                                                &#x03B1;                            i                                                y                            i                                   k           (                                       x                                         i                                   ,                        x                      )                          {\displaystyle \textstyle \mathbf {w} \cdot \varphi (\mathbf {x} )=\sum _{i}\alpha _{i}y_{i}k(\mathbf {x} _{i},\mathbf {x} )}    . به هر حال در حالت عادی w' وجود ندارد، به‌طوری‌که                                    w                  &#x22C5;         &#x03C6;         (                    x                  )         =         k         (                                 w             &#x2032;                             ,                    x                  )         .                 {\displaystyle \mathbf {w} \cdot \varphi (\mathbf {x} )=k(\mathbf {w'} ,\mathbf {x} ).}    
