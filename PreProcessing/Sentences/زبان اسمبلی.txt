زبان اَسمبلی (به انگلیسی&#58; Assembly language) یا همگذاری یک زبان برنامه‌نویسی سطح پایین برای رایانه‌ها و دیگر دستگاه‌های برنامه‌پذیر است که رابطهٔ یک-به-یک با دستورالعمل‌های زبان ماشین معماری رایانه دارد. هر زبان اسمبلی مختص به یک معماری رایانه خاص است، برخلاف بیشتر زبان‌های برنامه‌نویسی سطح بالا که با معماری‌های مختلف سازگار هستند ولی برای اجرا شدن به مفسر و مترجم نیاز دارند.
زبان اسمبلی با استفاده از یک برنامهٔ جانبی به نام اسمبلر یا همگذار، به کد ماشین قابل اجرا تبدیل می‌شود؛ به این فرایند تبدیل، اسمبل کردن (به انگلیسی&#58; Assembling) گفته می‌شود.
زبان اسمبلی از یادیارها برای نشان دادن هر دستور ماشین سطح-پایین یا آپ‌کد استفاده می‌کند. بعضی آپ‌کدها به یک یا چند عملوند به عنوان بخشی از دستورالعمل نیاز دارند و بیشتر اسمبلرها می‌توانند لیبل‌ها و نمادهایی را به عنوان عملوند، برای نشان دادن آدرس‌های حافظه و ثابت‌های عددی بپذیرند. ماکرو اسمبلرها نیز قابلیت درشت‌دستوری (به انگلیسی&#58; Macroinstruction) را شامل می‌شوند که این امکان را به وجود می‌آورد که متن یک کد زبان اسمبلی با یک نام از پیش تعیین شده در خلال متن یک کد دیگر استفاده شود. بیشتر اسمبلرها مکانیزم‌های اضافی برای تسهیل فرایند توسعهٔ برنامه، کنترل فرایند اسمبل کردن و پشتیبانی از اشکال‌زدایی ارائه کرده‌اند.
اسمبلر برنامه‌ای است که با تبدیل یادیارهای دستوری اسمبلی (به انگلیسی&#58; Assembly instruction mnemonics) به آپ‌کدها و جایگزینی شناسه‌ها با آدرس‌های حافظه، کد هدف (به انگلیسی&#58; Object code) را به وجود می‌آورد. استفاده از ارجاعات نمادی از ویژگی‌های کلیدی اسمبلرها است که از محاسبات خسته‌کننده و به‌روزرسانی‌های دستی آدرس‌ها بعد از تغییر کد برنامه توسط برنامه‌نویس جلوگیری می‌کند. بیشتر اسمبلرها از قابلیت ماکرو نیز بهره می‌برند که این امکان را به وجود می‌آورد تا یک نام خاص برای یک تکه کد مشخص شود و سپس از آن نام در قسمت‌های مختلف برنامه استفاده شود و در هنگام اسمبل کردن برنامه تکه کد مربوطه جایگزین نام آن شود؛ به عنوان مثال از این روش برای تولید توالی‌های دستوری کوتاه رایج در خلال متن برنامه به جای فراخوانی رویه‌ها استفاده می‌شود.
اسمبلرها از دههٔ ۱۹۵۰ مورد استفاده قرار گرفتند و نوشتن آنها بسیار راحت‌تر از نوشتن مترجم‌ها برای زبان‌های برنامه‌نویسی سطح بالا است به طوری که هر دستور یادیاری و هر آدرس حالت ترکیبی این زبان مستقیماً به یک آپ‌کد زبان ماشین تبدیل می‌شود. اسمبلرهای جدید، به‌طور خاص برای معماری‌های ریسک، مانند اسپارک و پاور، همانند معماری ایکس۸۶ و ایکس۸۶–۶۴، با بهینه‌سازی زمان‌بندی دستورالعمل‌ها باعث استفادهٔ کارآمد از خط لولهٔ واحد پردازش مرکزی می‌شوند.
هدف اصلی در استفاده از اسمبلرهای یکبار-گذر، سرعت اسمبل کردن بود زیرا در گذر دوم به برگرداندن و بازخوانی نوار یا کارت پانچ، که در گذشته برای ذخیره‌سازی کدها استفاده می‌شدند، نیاز بود. این مشکل بعدها با وجود کامپیوترهای جدید برطرف شد. مزیت اسمبلرهای چندبار-گذر این است که در نبود خطاها در کد آبجکت، فرایند پیونددهی سریع‌تر انجام می‌شود.
برنامه‌ای که به زبان اسمبلی نوشته می‌شود شامل مجموعه‌ای از دستورالعمل‌های پردازنده (یادیارها)، شبه-دستورها (به انگلیسی&#58; Pseudo-instructions)، کامنت‌ها و داده‌ها است. دستورهای زبان اسمبلی معمولاً از یک آپ‌کد و سپس فهرستی از داده‌ها، آرگومان‌ها یا پارامترها تشکیل شده‌اند و توسط اسمبلر به دستورهای زبان ماشین ترجمه و به حافظه منتقل می‌شوند تا اجرا شوند.
برای مثال، دستور زیر به پردازندهٔ معماری ایکس۸۶/آی‌ای-۳۲ می‌گوید که یک مقدار ثابت ۸ بیتی را به یک ثبات منتقل کند. کد باینری این دستور 10110 است که پس از آن یک شناسهٔ ۳ بیتی می‌آید تا مشخص کند کدام ثبات باید استفاده شود. 000 شناسهٔ ثبات AL است، بنابراین کد ماشین زیر دادهٔ 01100001 را در ثبات AL بار می‌کند:
در اینجا B0 به معنی انتقال مقدار بعدی به ثبات AL است و 61 نمایش مبنای ۱۶ مقدار باینری 01100001 است که باید منتقل شود و در مبنای ده برابر ۹۷ است. زبان اسمبلی اینتل یادیار MOV را (مخفف Move) برای دستورهای این چنینی فراهم کرده، به‌طوری‌که کد ماشین بالا در زبان اسمبلی به شکل زیر نوشته می‌شود که خواندن و به خاطر سپردن آن راحت‌تر است (آنچه بعد از نقطه-ویرگول (;) آمده توضیح (به انگلیسی&#58; comment) است):
برخی زبان‌های اسمبلی ممکن است از دستورهای مشابه MOV برای انتقال، کپی و بارگذاری داده‌ها، چه ثبات‌ها، چه مقادیر عددی و چه متغیرهای حافظه استفاده کنند و برخی دیگر از اسمبلرها ممکن از دستورهای متفاوتی استفاده کنند؛ مثلاً L برای انتقال حافظه به ثبات، ST برای انتقال از ثبات به حافظه، LR برای انتقال از ثبات به ثبات و MVI برای انتقال ثابت‌های عددی به ثبات و غیره.
آپ‌کد اینتل 10110000 (B0) یک مقدار ۸ بیتی را به ثبات AL کپی می‌کند، در حالیکه 10110001 (B1) آن را به CL منتقل می‌کند و 10110010 (B2) همین کار را با DL انجام می‌دهد. مثال‌های اسمبلی آن به صورت زیر است:
در هر حالت، دستور MOV مستقیماً توسط اسمبلر به یک آپ‌کد در بازهٔ 88-8E یا A0-A3 یا B0-B8 یا C6 یا C7 ترجمه می‌شود و برنامه‌نویس مجبور به دانستن یا حفظ کردن آن‌ها نیست.
تبدیل زبان اسمبلی به زبان ماشین وظیفهٔ اسمبلر است و عکس این عمل تا حدی توسط دی‌اسمبلر امکان‌پذیر است. برخلاف زبان‌های برنامه‌نویسی سطح بالا، ارتباط یک به یکی بین دستورهای زبان اسمبلی و دستورالعمل‌های زبان ماشین وجود دارد. با این حال، در برخی موارد، یک اسمبلر ممکن است شبه‌دستورهایی (به انگلیسی&#58; Pseudoinstructions) را به کار بگیرد (اساساً ماکروها) که به چند دستورالعمل زبان ماشین تبدیل می‌شود تا پاسخگوی نیازهای رایج باشد.
هر معماری کامپیوتر زبان ماشین مختص به خود را داراست. کامپیوترها در تعداد و نوع دستورهای قابل استفاده، تعداد و اندازهٔ ثبات‌ها و نحوهٔ انبارش داده‌ها با یکدیگر تفاوت دارند. با اینکه کامپیوترهای همه منظوره اساساً قادر به انجام کارکردهای مشابه هستند ولی این کار را با روش‌های گوناگونی انجام می‌دهند؛ بنابراین زبان اسمبلی مربوط به آن‌ها نیز این تفاوت‌ها را منعکس می‌کند.
مجموعه‌های متعددی از یادیارها یا دستورهای زبان اسمبلی ممکن است برای یک مجموعه دستورالعمل واحد وجود داشته باشد، که به‌طور معمول در برنامه‌های اسمبلی مختلفی نمونه‌سازی می‌شوند. در این موارد، رایج‌ترین آن‌ها معمولاً نمونه‌ای است که توسط کارخانهٔ سازنده عرضه می‌شود یا در مستندات آن‌ها استفاده شده‌است.
در زمانی که کامپیوتر با قابلیت ذخیره کردن برنامه معرفی شد، زبان‌های اسمبلی در دسترس نبودند. کثلین بوث مسئول اختراع زبان اسمبلی می‌باشد؛ که بر پایهٔ کار نظری اش که در سال ۱۹۷۴ آغاز کرد، می‌باشد. همزمان که با همفکری اندرو بوث (که در آینده همسر او شد) و با ریاضی‌دانی به نام جان فون نویمان و فیزیکدانی به نام هرمن گلداستاین در مؤسسه مطالعه‌های پیشرفته، بر روی ARC2 در دانشگاه لندن، بیرکبک کار می‌کرد. در اواخر ۱۹۴۸، محاسبه کننده ی خودکار مخزن تأخیر الکترونیکی (EDSAC) یک اسمبلر (به نام دستورهای اولیه) داشت که با برنامهٔ خودراه انداز آن دستگاه یکپارچه شده بود. از حافظه ای تک حرفی استفاده می‌کرد که به وسیلهٔ دیوید ویلر توسعه یافت. کسی که به عنوان سازندهٔ اولین اسمبلر، مسئول جامعهٔ کامپیوتر IEEE می‌باشد. گزارش‌های دربارهٔ EDSAC، اسمبلی را برای فرایند ترکیب زمینه‌ها برای رسیدن به یک کلمهٔ راهنما معرفی کردند. SOAP (برنامهٔ اسمبلی بهینهٔ نمادین) یک زبان اسمبلی برای کامپیوتر IBM 650 بود که به وسیلهٔ استن پلی در ۱۹۵۵ نوشته شد. زبان اسمبلی تعداد زیادی از نیازهای مستعد خطا، خسته کننده و وقت گیر برنامه‌نویسی نسل اول با اولین کامپیوترها را ازبین برد؛ و برنامه نویسان را از موارد خسته کننده ای از جمله به خاطر سپردن کدهای عددی و محاسبه کردن آدرس‌ها آزاد کرد. آن‌ها یک بار به‌طور گسترده برای همهٔ انواع برنامه‌نویسی استفاده شدند. با این حال در دههٔ ۱۹۸۰ (در دههٔ ۱۹۹۰ برای ریزرایانه‌ها) در جستجو برای بهره‌وری برنامه‌نویسی که اثبات شده‌است، استفاده از آنها به مقدار زیادی با زبان‌های سطح بالا جایگزین شد. امروزه زبان اسمبلی هنوز برای دست کاری دستی سخت‌افزار، دسترسی به دستورالعمل‌های مخصوص پردازنده، یا برای آدرس دهی موضوع‌های ساختاری بحرانی استفاده می‌شود. نمونه‌های استفاده عبارت اند از گرداننده‌های دستگاه، سیستم‌های نهفتهٔ سطح پایین، و سیستم‌های بی درنگ. از دید تاریخی، برنامه‌های متعددی وجود دارند که کاملاً به زبان اسمبلی نوشته شده‌اند. باروز ام‌سی‌پی(۱۹۶۱)(Burroughs MCP) اولین کامپیوتری بود که سیستم عملیاتی به‌طور کامل به زبان اسمبلی توسعه نیافته بود؛ بلکه در زبان مشکل محور سیستم‌های اجرایی (ESPOL) ـ که یک گویش از الگول (زبان الگوریتمی) می‌باشد ـ نوشته شده بود. همچنین بسیاری از کاربردهای تجاری به زبان اسمبلی نوشته شدند. به انضمام مقدار زیادی نرم‌افزارهای رایانه‌های بزرگ آی‌بی‌ام که نوشته شده به وسیلهٔ شرکت‌های بزرگ بود. کوبول، فورترن و بعضی از PL/Iها سرانجام جایگزین مقدار زیادی از این کار شدند. اگرچه تعدادی از سازمان‌های بزرگ در دههٔ ۱۹۹۰، کاربرد زیرساخت‌هایی با زبان‌های اسمبلی را به خوبی حفظ کردند. بیشتر ریزرایانه‌های اولیه بر زبان اسمبلی از نوع کدگذاری دستی تکیه کردند. به انضمام بیشتر سیستم‌های عملیاتی و برنامه‌های بزرگ. این بخاطر این بود که این سیستم‌ها محدودیت‌های شدید منابع، ساختارهای حافظه و نمایش ویژهٔ تحمیلی و سرویس‌های سیستمی مشکل دار و محدود شده آماده شده داشتند. احتمالاً فقدان کامپایلرهای با زبان سطح بالای درجه یک مناسب برای استفاده ریزرایانه چیز مهمتری بود. یک عامل روانشناسانه نیز احتمالاً نقش بازی می‌کرد: اولین نسل برنامه نویسان ریزرایانه‌ها که باقی ماندند افراد دیوانهٔ بازی با نگرشی خاص بودند. در مفهومی تجاری تر، حداقل اندازه، حداقل میزان پردازش مورد نیاز، سرعت بهتر و قابل اعتماد بودن از بزرگ‌ترین دلایل برای استفاده از زبان اسمبلی بودند. سیستم عملیاتی IBM PC DOS، کامپایلر توربو پاسکال و برنامه‌های اولیه مانند برنامهٔ صفحه گسترده ی لوتوس ۱-۲-۳، مثال‌های نمونهٔ برنامه‌های بزرگ با زبان اسمبلی در این زمان می‌باشند. زبان اسمبلی در گذشته بهترین نمایش را در سگا ساترن - برای توسعه و برنامه‌نویسی بازی‌های این کنسول که به‌طور آشکار چالش‌برانگیز بود - داشت. بازی ان بی ای جم که یک بازی مخصوص دستگاه‌های بازی ویدئویی بود، مثال دیگری می‌باشد. زبان اسمبلی برای یک مدت طولانی زبان اصلی توسعه برای بسیاری از بازی‌های کامپیوتری در دهه‌های ۱۹۸۰ و ۱۹۹۰ بود (از جمله ام‌اس‌ایکس، سینکلر زد ایکس اسپکتروم، کمودور ۶۴، کومودور آمیگا و آتاری اس‌تی). این در بخش بزرگی بود زیرا گویش پایهٔ تفسیری در این سیستم‌ها با عث سرعت اجرایی ناکافی می‌شد همچنان که باعث قابلیت‌های ناکافی برای بدست آوردن همهٔ مزیت‌های سخت‌افزار موجود در این سیستم‌ها می‌شد. بعضی از سیستم‌ها حتی یک محیط یکپارچه توسعه نرم‌افزار (IDE) دارند که دارای قابلیت فوق پیشرفته اشکال زدایی و قابلیت‌های ماکروها هستند. بعضی از کامپایلرهای در دسترس برای ریدیوشک تی آر اس-۸۰ و جانشینانش، قابلیت ترکیب برخط منبع اسمبلی با جمله‌های سطح بالای برنامه را داشتند. پس از گردآوری، یک اسمبلر درونی کدهای برخط ماشین را تولید کرد.
همواره بحث‌هایی دربارهٔ کاربردی بودن و نمایش زبان اسمبلی در مقابل زبان‌های سطح بالا بوده‌است. اگرچه در جایگاه‌های مخصوصی که اهمیت دارند، زبان اسمبلی استفاده می‌شود (بالا را مشاهده کنید)،  اما ابزارهای دیگری برای بهینه‌سازی وجود دارند. در ژوئیه ۲۰۱۷ شاخص تیوبی رتبهٔ محبوبیت زبان برنامه‌نویسی، زبان اسمبلی در رتبهٔ ۱۱ بالاتر از مثلاً ویژوال بیسیک بود. اسمبلر می‌تواند برای بهینه‌سازی سرعت یا بهینه‌سازی اندازه استفاده شود. در حالت بهینه‌سازی سرعت، کامپایلرهای بهینه‌ساز مدرن مدعی می‌شوند که زبان‌های سطح بالا را به کدهایی تبدیل می‌کنند که می‌توانند به سرعت اسمبل با دست نوشته شده اجرا شوند، گرچه مثال‌های خلاف هم می‌توانند پیدا شوند. پیچیدگی پردازنده‌های مدرن و سیستم‌های فرعی حافظه‌ها، بهینه‌سازی مؤثر را به‌طور افزاینده ای برای کامپایلر و همچنین برای برنامه نویسان اسمبلی سخت می‌کنند. علاوه بر این افزایش نمایش پردازنده‌ها به این معنی است که بیشتر سی پی یوها بیشتر مواقع بی فایده مانده‌اند، با تأخیرهایی که به خاطر تنگه‌های قابل پیش‌بینی مانند از دست دادن حافظهٔ پنهان، عملیات‌ها و صفحه بندی I/O رخ داده‌است. همین، سرعت اجرای کد خام را برای بسیاری از برنامه نویسان بی‌اهمیت کرده‌است. در اینجا تعدادی موقعیت وجود دارد که احتمالاً توسعه دهندگان انتخاب بکنند تا از زبان اسمبلی استفاده بکنند.
زبان اسمبلی هنوز در بسیاری از برنامه‌های مهندسی برق و علوم کامپیوتر آموزش داده می‌شود. اگرچه تعداد کمی از برنامه نویسان امروزه معمولاً با زبان اسمبلی به عنوان ابزار کار می‌کنند، اما مفاهیم اصولی بااهمیت باقی می‌مانند. مفاهیم ابتدایی از جمله اعمال ریاضی در اعداد دو دویی]]، اختصاص حافظه، پردازش پشته، کدگذاری مجموعهٔ کاراکترها، قطع شدن پردازش و طراحی کامپایلر که مطالعه در تفاصیل آن‌ها بدون فهمیدن اینکه یک کامپیوتر چگونه در سطح سخت‌افزار عمل می‌کند، سخت خواهد بود. از زمانی که رفتار کامپیوتر، به شکل ابتدایی به وسیلهٔ مجموعهٔ دستور العمل‌هایش تعریف می‌شود، راه منطقی برای یادگرفتن چینن مفهوم‌هایی، مطالعهٔ که یک زبان اسمبلی است. بیشتر کامپیوترهای مدرن مجموعهٔ دستور العمل‌های مشابه دارند؛ بنابراین مطالعهٔ تنها یک زبان اسمبلی کافی است برای یادگیری: I) مفاهیم پایه؛ II) تشخیص موقعیت‌هایی که استفاده از زبان اسمبلی می‌تواند مناسب باشد؛ III) دیدن اینکه چه مقدار کد قابل اجرای کارآمد از یک زبان سطح بالا می‌تواند ساخته شود.
