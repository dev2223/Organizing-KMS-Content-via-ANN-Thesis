در علوم رایانه، یک درخت پسوندی (درخت PAT، که با نام قدیمی‌تر درخت موقعیت نیز شناخته شده است) یک ترای شامل پسوندهای یک رشته‌ی داده شده به عنوان کلید و مکان آنها در رشته به عنوان مقدار است. درخت‌های پسوندی پیاده‌سازی سریع شمار زیادی از عملیات‌های رشته‌ای مهم را ممکن می‌سازند.
درخت پسوندی برای یک رشتهٔ                         S                 {\displaystyle S}    ، درختی است که یال‌های آن با رشته‌هایی برچسب خورده‌اند، به طوری که هر پسوند                         S                 {\displaystyle S}    ، متناظر با دقیقاً یک مسیر از ریشهٔ درخت به یک برگ است؛ بنابراین، این درخت، یک درخت مبنا برای پسوندهای                         S                 {\displaystyle S}     خواهد بود.
ساخت چنین درختی برای رشتهٔ                         S                 {\displaystyle S}     به زمان و فضای خطی بر حسب طول                         S                 {\displaystyle S}     نیاز دارد. وقتی این درخت ساخته شود، عملیات رشته‌ای، مانند یافتن یک زیررشته در                         S                 {\displaystyle S}    ، یافتن یک زیررشته با یک تعداد مجاز مشخص شده برای خطاها، یافتن تطابق‌ها برای یک الگوی عبارت باقاعده و غیره، می‌توانند به سرعت انجام شوند. درخت‌های پسوندی یکی از اولین راه حل‌های با زمان خطی برای مسئلهٔ بزرگترین زیررشته مشترک را نیز میسر ساخته‌اند. این افزایش سرعت‌ها هزینه‌ای دارند: ذخیره‌سازی یک درخت پسوندی برای یک رشته، معمولاً به فضای بیشتری نسبت به ذخیره‌سازی خود رشته نیاز دارد.
درخت پسوندی برای رشتهٔ                         S                 {\displaystyle S}     با طول                         n                 {\displaystyle n}     درختی است که در شرایط زیر صدق کند:
از آنجایی که یک اینچنین درختی برای همهٔ رشته‌ها وجود ندارد، به انتهای                         S                 {\displaystyle S}    ، یک کاراکتر ترمینال (معمولاً با $ نشان می‌دهند) که در الفبای اصلی وجود ندارد الحاق می‌شود. مثلا اگر سعی کنید برای رشته abab آن را بسازید متوجه این نکته می‌شوید چون پسوند ab  پیشوند پسوند رشته کامل(abab) است. از آنجایی که تمامی گره‌های داخلی به جز ریشه شاخه شاخه می‌شوند، تعداد این گره‌ها حداکثر                         n         &#x2212;         1                 {\displaystyle n-1}     خواهد بود و تعداد کل گره‌ها برابر خواهد بود با                         n         +         (         n         &#x2212;         1         )         +         1         =         2         n                 {\displaystyle n+(n-1)+1=2n}     (                        n                 {\displaystyle n}     برگ،                         n         &#x2212;         1                 {\displaystyle n-1}     گره داخلی، و یک ریشه).
درخت پسوندی داده ساختاری است که با ساخت آن میتوان انواع مختلف پرسمان‌ها را پاسخ داد. ساخت آن با شرایطی در                          O         (         n         )                 {\displaystyle O(n)}     قابل انجام است. یکی از کاربرد‌های اصلی آن جستجوی رشته است.
در حوضه بیوانفورماتیک یکی از مسائل معروف و اصلی پیدا کردن تعدادی الگوی‌ خوانده شده از ژنوم ( read ) در رشته طولانی‌تر( Text ) است. ابعاد read ها در حد چند صد حرف و ابعاد ژنوم در حد میلیارد هستند. الگوریتم تطابق رشته با زمان خطی‌ برای یک الگو برای این مسئله مناسب نیستند و اگر روی تمام read ها به ترتیب اجرا کنیم بهینه نیست، چون تعداد آن‌ها بسیار زیاد است. ساختار درخت پسوندی طوری است که چون تمام پسوند‌های رشته در یک درخت پیشوندی ذخیره شده اند. با جستجوی یک pattern خاص از ریشه، تمام پسوند‌های  Text که با آن الگو شروع می‌شوند در زیردرخت راسی که در‌نهایت روی آن هستیم موجود اند. پس در پیچیدگی                         O         (                    |                  p         a         t         t         e         r         n                    |                  )                 {\displaystyle O(|pattern|)}     روی هر الگو تکرار‌های آن پیدا می‌شوند. مقدار پیچیدگی زمانی کل هم                          O         (         n         +                    &#x2211;                                       p                                i                                         &#x2208;             p             a             t             t             e             r             n             s                                        |                             p                        i                                        |                  )                 {\displaystyle O(n+\sum \nolimits _{p_{i}\in patterns}|p_{i}|)}     می‌شود.
به دلیل خواص خوبی که درخت‌های پسوندی دارند از آن‌ها برای ویرایش متن، جست‌وجوی متن آزاد، زیست‌شناسی محاسباتی و دیگر حوزه‌ها استفاده می‌شود. کاربردهای اولیه عبارتند از:
درخت‌های پسوندی اغلب در حوزه‌ی بیوانفورماتیک استفاده می‌شوند، برای جست‌وجوی الگوها در دنباله‌های دی‌ان‌ای یا دنباله‌های پروتئینی (که می‌توان آنها را به عنوان رشته‌های بلندی از حروف در نظر گرفت). توانایی جست‌وجوی کارآمد با عدم تطابق ممکن است بزرگترین قدرت درخت‌های پسوندی باشد. این داده ساختارها همچنین در فشرده‌سازی داده‌ها استفاده می‌شوند؛ می‌توان برای پیدا کردن داده‌های تکراری و نیز در مرحله‌ی مرتب‌سازی تبدیل باروز-ویلر از آنها استفاده کرد. گونه‌هایی از طرح‌های فشرده‌سازی LZW از درخت‌های پسوندی استفاده می‌کنند (LZSS). در خوشه‌بندی درخت پسوندی (یک الگوریتم خوشه‌بندی که در برخی از موتورهای جست‌وجو استفاده می‌شود) نیز از درخت‌های پسوندی استفاده می‌شود.
اگر هر گره و یال را بتوان در فضای حافظه‌ای از                         &#x0398;         (         1         )                 {\displaystyle \Theta (1)}     ذخیره کرد، می‌توان تمام درخت را در فضای حافظه‌ای از                         &#x0398;         (         n         )                 {\displaystyle \Theta (n)}     ذخیره نمود. جمع طول تمامی رشته‌های روی همه‌ی یال‌ها در درخت از                         O         (                    n                        2                             )                 {\displaystyle O(n^{2})}     است، اما هر یال می‌تواند با دو عدد به صورت مکان و طول زیررشته‌ای از                         S                 {\displaystyle S}     ذخیره شود؛ که در کل ذخیره‌ی همه‌ی یال‌ها حافظه‌ای از                         &#x0398;         (         n         )                 {\displaystyle \Theta (n)}     اشغال می‌کند.
به عنوان یک روش ساده برای حالتی که طول رشته کوتاه است می‌توانیم از آن استفاده کنیم. کافی است تمام پسوند‌ها را در یک درخت پیشوندی درج کنیم.
این الگوریتم ساخت درخت پسوندی را به تعداد فاز تقسیم می‌کند که هرکدام مراحلی دارند. در فاز                         i                 {\displaystyle i}     ام، برای اولین بار حرف                         i                 {\displaystyle i}     ام رشته را در نظر میگیریم و بعد از تمام شدن آن انتظار داریم تمام پسوند‌های زیررشته                         S         [         1..         i         ]                 {\displaystyle S[1..i]}     در درخت درج شده باشند. در هر مرحله                         j                 {\displaystyle j}     از این فاز،                         S         [         j         .         .         i         ]                 {\displaystyle S[j..i]}     درج می‌شود. قبل از فاز                         i                 {\displaystyle i}     ام فاز                         i         &#x2212;         1                 {\displaystyle i-1}     تمام شده، پس رشته                         S         [         j         .         .         i         &#x2212;         1         ]                 {\displaystyle S[j..i-1]}     را داخل درخت جستجو می‌کنیم. ۳ حالت امکان دارد رخ دهد که در هر حالت طبق قانون خاصی ادامه می‌دهیم.
 اگر همه فاز‌ها و مراحل را به شکل جستجوی جامع انجام دهیم چون                         n                 {\displaystyle n}     فاز                         n                 {\displaystyle n}     مرحله‌ای داریم و جستجوی درخت هم                         O         (         n         )                 {\displaystyle O(n)}     است در نهایت الگوریتم از                         O         (                    n                        3                             )                 {\displaystyle O(n^{3})}     می‌شود. برای کاهش آن از پیوند‌های پسوندی استفاده می‌کنیم.
تعریف پیوند پسوندی: فرض کنید رشته                         X                 {\displaystyle X}     در درخت وجود دارد و مسیر آن به راس                         v                 {\displaystyle v}     ختم می‌شود. رشته                         a         X                 {\displaystyle aX}     ‌(                         a                 {\displaystyle a}     حرفی دلخواه از الفبا) هم موجود است و به راس                         u                 {\displaystyle u}     ختم می‌شود. به پیوندی از راس                         u                 {\displaystyle u}     به                         v                 {\displaystyle v}     پیوند پسوندی گفته می‌شود. در شکل اول این پیوند‌ها با خط‌چین نشان داده شده‌اند.
وقتی در حال انجام مرحله                         j                 {\displaystyle j}     فاز                         i                 {\displaystyle i}     هستیم، باید انتهای مسیر                         S         [         j         .         .         i         &#x2212;         1         ]                 {\displaystyle S[j..i-1]}     را بدانیم. همچنین در مرحله                         j         +         1                 {\displaystyle j+1}     مسیر                         S         [         j         +         1..         i         &#x2212;         1         ]                 {\displaystyle S[j+1..i-1]}    . قبل از انجام فاز                         i                 {\displaystyle i}     فاز                         i         &#x2212;         1                 {\displaystyle i-1}     انجام شده یعنی دو رشته                         S         [         j         .         .         i         &#x2212;         1         ]                 {\displaystyle S[j..i-1]}     و                         S         [         j         +         1..         i         &#x2212;         1         ]                 {\displaystyle S[j+1..i-1]}     در درخت هستند.                         S         [         j         .         .         i         &#x2212;         1         ]                 {\displaystyle S[j..i-1]}     همان                         S         [         j         ]         [         j         +         1..         i         &#x2212;         1         ]                 {\displaystyle S[j][j+1..i-1]}     است پس ما یک پیوند پسوندی از راس انتهایی                         S         [         j         .         .         i         &#x2212;         1         ]                 {\displaystyle S[j..i-1]}     به                         S         [         j         +         1..         i         &#x2212;         1         ]                 {\displaystyle S[j+1..i-1]}     داریم پس به جای جستجو از ریشه می‌توانیم از آن استفاده کنیم. در این حالت صرفا زمان جستجو بهتر می‌شود تا به                         O         (                    n                        2                             )                 {\displaystyle O(n^{2})}     برسیم. 
برای اینکه پیچیدگی زمان                         O         (         n         )                 {\displaystyle O(n)}     شود حتما باید رشته‌های روی یال را به صورت زیر‌بازه‌ای از رشته اصلی ذخیره کنیم.                         s         [         s         t         a         r         t         I         n         d         e         x         .         .         e         n         d         I         n         d         e         x         ]                 {\displaystyle s[startIndex..endIndex]}     با ذخیره دو عدد شروع و پایان.
قوانینی که به آن اشاره شد، در یک فاز به ترتیب عمل می‌کنند. یعنی اولین مراحل قانون ۱ عمل می‌کند،‌ بعد مدتی دومی و در آخر همیشه حالت سوم رخ خواهد داد. پس مثلا وقتی به حالت ۳ برسیم دیگر انجام آن فاز عملا تمام شده. وقتی یک برگ جدید میسازیم، همیشه برگ باقی می‌ماند صرفا امکان دارد یال آن به پدرش طولانی شود.(در حالت ۱) همچنین برای تمام برگ‌ها                         e         n         d         I         n         d         e         x                 {\displaystyle endIndex}     یکسان می‌ماند. پس در هر فاز قانون یک در زمان ثابت با ذخیره با لیست همگانی از                         e         n         d         I         n         d         e         x                 {\displaystyle endIndex}     های برگ‌ها قابل انجام است. 
وقتی قانون دوم اجرا می‌شود هم، برگ جدید ایجاد می‌شود. و اگر یکبار در مرحله                         j                 {\displaystyle j}     اجرا شود، در تمامی فاز‌های بعدی این مرحله قانون اول رخ می‌دهد. پس در بدترین حالت                         n                 {\displaystyle n}     بار اجرا می‌شود چون                         n                 {\displaystyle n}     برگ داریم. پس طبق خاصیت‌های گفته شده مرتبه زمانی به                         O         (         n         )                 {\displaystyle O(n)}     کاهش پیدا کرد. 
یک نمونه از پیاده‌سازی آن به زبان                         C         +         +                 {\displaystyle C++}     را در اینجا ببینید. 
 یک انتخاب مهم هنگام پیاده‌سازی یک درخت پسوندی، رابطه‌ی پدر-فرزندی بین گره‌ها است. استفاده از یک نوع لیست پیوندی به نام لیست خواهر و برادرها متداول‌ترین نوع است. هر گره یک اشاره‌گر به فرزند اولش و یک اشاره‌گر به فرزند بعدی در لیست فرزندهایی که عضو آنها است، دارد. پیاده‌سازی‌های دیگر با زمان اجرای کارآمد از جداول درهم‌سازی، آرایه‌های مرتب یا نامرتب، (آرایه پویا)، یا درخت‌های جست‌وجوی دودویی خود-متوازن استفاده می‌کنند.
اگر                         &#x03C3;                 {\displaystyle \sigma }     تعداد حروف الفبا باشد، هزینه‌ها به شرح زیر است:
                                                                                                                  Lookup                                                                                   Insertion                                                                                   Traversal                                                                                                             Sibling lists / unsorted arrays                                                                O                 (                 &#x03C3;                 )                                               &#x0398;                 (                 1                 )                                               &#x0398;                 (                 1                 )                                                                                            Bitwise sibling trees                                                                O                 (                 log                 &#x2061;                 &#x03C3;                 )                                               &#x0398;                 (                 1                 )                                               &#x0398;                 (                 1                 )                                                                                            Hash maps                                                                &#x0398;                 (                 1                 )                                               &#x0398;                 (                 1                 )                                               O                 (                 &#x03C3;                 )                                                                                            Balanced search tree                                                                O                 (                 log                 &#x2061;                 &#x03C3;                 )                                               O                 (                 log                 &#x2061;                 &#x03C3;                 )                                               O                 (                 1                 )                                                                                            Sorted arrays                                                                O                 (                 log                 &#x2061;                 &#x03C3;                 )                                               O                 (                 &#x03C3;                 )                                               O                 (                 1                 )                                                                                            Hash maps + sibling lists                                                                O                 (                 1                 )                                               O                 (                 1                 )                                               O                 (                 1                 )                                                                 {\displaystyle {\begin{array}{r|lll}&amp;{\text{Lookup}}&amp;{\text{Insertion}}&amp;{\text{Traversal}}\\\hline {\text{Sibling lists / unsorted arrays}}&amp;O(\sigma )&amp;\Theta (1)&amp;\Theta (1)\\{\text{Bitwise sibling trees}}&amp;O(\log \sigma )&amp;\Theta (1)&amp;\Theta (1)\\{\text{Hash maps}}&amp;\Theta (1)&amp;\Theta (1)&amp;O(\sigma )\\{\text{Balanced search tree}}&amp;O(\log \sigma )&amp;O(\log \sigma )&amp;O(1)\\{\text{Sorted arrays}}&amp;O(\log \sigma )&amp;O(\sigma )&amp;O(1)\\{\text{Hash maps + sibling lists}}&amp;O(1)&amp;O(1)&amp;O(1)\end{array}}}    
