یک شبکه‌ی عصبی مکرر (RNN) کلاسی از شبکه‌های عصبی مصنوعی هستند که در آن اتصالات مابین گره‌هایی از یک گراف جهت‌دار در امتداد یک دنباله‌ی زمانی می‌باشند و سبب می‌شود تا الگوریتم بتواند رفتار پویای موقتی را به نمایش بگذارد. برخلاف شبکه‌های عصبی رو به جلو، شبکه‌های عصبی مکرر می‌توانند از وضعیت درونی خود برای پردازش دنباله‌ی ورودی‌ها استفاده کنند که آن‌ها را برای مواردی نظیر تشخیص صوت، یا تشخیص دست‌نوشته‌های غیربخش‌بندی شده‌ی متصل مناسب می‌کند. 
واژه‌ی «شبکه‌های عصبی مکرر» به دو کلاس گسترده از شبکه‌هایی با ساختار مشابه اشاره دارد: یکی از آن‌ها دارای تکانه متناهی و دیگری دارای تکانه نامتناهی می‌باشد و هر دوی آن‌ها رفتار پویای موقتی را نشان می‌دهند. یک شبکه‌ی متناهی تکانه، یک گراف جهت‌دار غیر مدور است که می‌تواند باز شده و با یک شبکه‌ی عصبی رو به جلو جایگزین شود؛ در حالی که یک شبکه‌ی با تکانه نامتناهی یک گراف مدور جهت‌دار است که نمی‌تواند باز شود. 
هر دوی این الگوریتم‌ها می‌توانند دارای وضعیت‌های ذخیره‌سازی شده باشند و این حافظه‌ی ذخیره‌سازی نیز می‌تواند تحت کنترل مستقیم شبکه‌ی عصبی باشد. همچنین در صورتی که دارای تأخیر زمانی باشد یا دارای چرخه‌های بازخوردی باشد، حافظه‌ی مذکور می‌تواند با شبکه‌ی دیگری یا گراف دیگری جایگزین شود. این وضعیت‌های تحت کنترل، به وضعیت‌های درگاهی یا حافظه‌های درگاهی اشاره دارند و بخشی از شبکه‌های حافظه‌ی کوتاه‌مدت بلند (LSTMs) و واحدهای درگاهی مکرر هستند.
شبکه های عصبی مکرر بر اساس کار دیوید روملهارت در سال 1986 بود. شبکه های هاپفیلد - نوع خاصی از RNN - توسط جان هاپفیلد در سال 1982 (دوباره) کشف شد. در سال 1993، یک سیستم کمپرسور تاریخ عصبی یک کار "آموزش بسیار عمیق" را حل کرد که به بیش از 1000 لایه بعدی در یک RNN نیاز داشت که در زمان باز شده بود.
در حدود سال 2007، LSTM شروع به ایجاد انقلابی در تشخیص گفتار کرد و از مدل‌های سنتی در کاربردهای گفتاری خاص بهتر عمل کرد. در سال 2009، یک شبکه LSTM آموزش دیده با طبقه‌بندی زمانی ارتباط‌گرا (CTC) اولین RNN بود که برنده مسابقات تشخیص الگو شد، زمانی که چندین مسابقه در تشخیص دست‌خط متصل برنده شد. در سال 2014، شرکت چینی Baidu از RNN های آموزش دیده با CTC برای شکستن معیار مجموعه داده تشخیص گفتار 2S09 Hub5'00  بدون استفاده از هیچ روش سنتی پردازش گفتار استفاده کرد.
شبکه‌های عصبی کاملاً مکرر (FRNN) خروجی‌های همه نورون‌ها را به ورودی‌های همه نورون‌ها متصل می‌کنند. این عمومی‌ترین توپولوژی شبکه عصبی است، زیرا همه توپولوژی‌های دیگر را می‌توان با صفر کردن وزن‌های اتصال برای شبیه‌سازی عدم اتصال بین آن نورون‌ها نشان داد. تصویر سمت راست ممکن است برای بسیاری گمراه‌کننده باشد، زیرا توپولوژی‌های عملی شبکه‌های عصبی اغلب در "لایه‌ها" سازمان‌دهی می‌شوند و طراحی آن ظاهر را نشان می‌دهد. با این حال، آنچه که لایه ها به نظر می رسد، در واقع، مراحل مختلف در زمان یک شبکه عصبی کاملاً مکرر هستند. سمت چپ ترین مورد در تصویر، اتصالات مکرر را به صورت قوس با برچسب 'v' نشان می دهد. برای ایجاد ظاهر لایه ها به موقع "باز می شود".
شبکه المان (Elman network)یک شبکه سه لایه است (که در تصویر به صورت x، y و z مرتب شده اند) با اضافه شدن مجموعه ای از واحدهای زمینه (u در تصویر). لایه میانی (پنهان) به این واحدهای زمینه ثابت با وزن یک متصل می شود. در هر مرحله زمانی، ورودی به جلو هدایت می شود و یک قانون یادگیری اعمال می شود. اتصالات پشتی ثابت یک کپی از مقادیر قبلی واحدهای پنهان را در واحدهای زمینه ذخیره می کنند (زیرا قبل از اعمال قانون یادگیری روی اتصالات منتشر می شوند). بنابراین شبکه می تواند نوعی حالت را حفظ کند و به آن اجازه می دهد کارهایی مانند پیش بینی توالی را انجام دهد که فراتر از توان یک پرسپترون چند لایه استاندارد است.
شبکه های جردن(Elman network)مشابه شبکه های المان هستند. واحدهای زمینه از لایه خروجی به جای لایه پنهان تغذیه می شوند. واحدهای زمینه در شبکه جردن نیز به عنوان لایه حالت نامیده می شوند. آنها یک ارتباط مکرر با خودشان دارند.
شبکه هاپفیلد یک RNN است که در آن تمام اتصالات بین لایه ها به یک اندازه هستند. به ورودی‌های ثابت نیاز دارد و بنابراین یک RNN عمومی نیست، زیرا دنباله‌ای از الگوها را پردازش نمی‌کند. با این حال، تضمین می کند که همگرا خواهد شد. اگر اتصالات با استفاده از یادگیری هبیان آموزش داده شوند، شبکه هاپفیلد می تواند به عنوان حافظه قابل آدرس دهی محتوا قوی و مقاوم در برابر تغییر اتصال عمل کند.
یک شبکه حافظه انجمنی دو جهته (BAM) که توسط بارت کوسکو معرفی شد، نوعی از شبکه هاپفیلد است که داده‌های انجمنی را به صورت برداری ذخیره می‌کند. دو جهتی از انتقال اطلاعات از طریق یک ماتریس و جابجایی آن ناشی می شود. به طور معمول، رمزگذاری دوقطبی به رمزگذاری باینری جفت های انجمنی ترجیح داده می شود. اخیراً، مدل‌های BAM تصادفی با استفاده از پله‌بندی مارکوف برای افزایش پایداری شبکه و ارتباط با کاربردهای دنیای واقعی بهینه‌سازی شده‌اند.
یک شبکه BAM دارای دو لایه است که هر یک از آنها می تواند به عنوان ورودی برای فراخوانی یک ارتباط و تولید خروجی در لایه دیگر هدایت شود.
شبکه حالت اکو (ESN) دارای یک لایه پنهان تصادفی پراکنده است. وزن نورون های خروجی تنها بخشی از شبکه است که می تواند تغییر کند (آموزش داده شود). ESN ها در بازتولید سری های زمانی خاص خوب هستند. گونه‌ای برای نورون‌های spiking به عنوان ماشین حالت مایع شناخته می‌شود.
شبکه عصبی بازگشتی مستقل (IndRNN) مشکلات ناپدید شدن و انفجار گرادیان را در RNN سنتی کاملا متصل می کند. هر نورون در یک لایه فقط حالت گذشته خود را به عنوان اطلاعات زمینه دریافت می کند (به جای اتصال کامل به همه نورون های دیگر در این لایه) و بنابراین نورون ها مستقل از تاریخ یکدیگر هستند. پس انتشار گرادیان را می توان برای جلوگیری از ناپدید شدن گرادیان و انفجار به منظور حفظ حافظه بلند مدت یا کوتاه مدت تنظیم کرد. اطلاعات متقابل نورون در لایه های بعدی بررسی می شود. IndRNN را می توان با توابع غیرخطی غیراشباع مانند ReLU به طور قوی آموزش داد. با استفاده از اتصالات پرش، می توان شبکه های عمیق را آموزش داد.
یک شبکه عصبی بازگشتی با اعمال مجموعه ای از وزن ها به صورت بازگشتی بر روی یک ساختار گراف مانند قابل تمایز با پیمایش ساختار به ترتیب توپولوژیکی ایجاد می شود. چنین شبکه‌هایی معمولاً توسط حالت معکوس تمایز خودکار نیز آموزش داده می‌شوند. آنها می توانند نمایش های توزیع شده ساختار، مانند اصطلاحات منطقی را پردازش کنند. یک مورد خاص از شبکه های عصبی بازگشتی، RNN است که ساختار آن با یک زنجیره خطی مطابقت دارد. شبکه‌های عصبی بازگشتی برای پردازش زبان طبیعی استفاده شده‌اند. شبکه تانسور عصبی بازگشتی از یک تابع ترکیب مبتنی بر تانسور برای همه گره‌های درخت استفاده می‌کند.
کمپرسور تاریخچه عصبی یک پشته بدون نظارت از RNN است. در سطح ورودی، یاد می گیرد که ورودی بعدی خود را از ورودی های قبلی پیش بینی کند. فقط ورودی‌های غیرقابل پیش‌بینی برخی از RNN در سلسله مراتب به ورودی‌های سطح بالاتر RNN تبدیل می‌شوند، که بنابراین به ندرت حالت داخلی خود را دوباره محاسبه می‌کند. بنابراین هر سطح بالاتر RNN نمایش فشرده ای از اطلاعات در RNN زیر را مطالعه می کند. این کار به گونه ای انجام می شود که بتوان دنباله ورودی را دقیقاً از نمایش در بالاترین سطح بازسازی کرد.
این سیستم به طور موثر طول توصیف یا لگاریتم منفی احتمال داده ها را به حداقل می رساند. با توجه به قابلیت پیش‌بینی‌پذیری زیاد در توالی داده‌های ورودی، بالاترین سطح RNN می‌تواند از یادگیری نظارت شده برای طبقه‌بندی آسان حتی توالی‌های عمیق با فواصل طولانی بین رویدادهای مهم استفاده کند.
می توان سلسله مراتب RNN را به دو RNN تقطیر کرد: chunker "آگاهانه" (سطح بالاتر) و خودکار "ناخودآگاه" (سطح پایین تر).هنگامی که قطعه‌کننده یاد گرفت ورودی‌هایی را که توسط اتومایزر غیرقابل پیش‌بینی هستند، پیش‌بینی و فشرده کند، می‌توان خودکارساز را در مرحله یادگیری بعدی مجبور کرد تا از طریق واحدهای اضافی، واحدهای پنهان قطعه‌کننده که به کندی تغییر می‌کند را پیش‌بینی یا تقلید کند. این امر یادگیری حافظه های مناسب و به ندرت در فواصل زمانی طولانی را برای خودکارساز آسان می کند. به نوبه خود، این به خودکار کمک می‌کند تا بسیاری از ورودی‌های غیرقابل پیش‌بینی خود را قابل پیش‌بینی کند، به طوری که chunker می‌تواند روی رویدادهای غیرقابل پیش‌بینی باقی‌مانده تمرکز کند.
یک مدل مولد تا حدی بر مشکل گرادیان ناپدید شدن تمایز خودکار یا انتشار پس‌باز در شبکه‌های عصبی در سال 1992 غلبه کرد. در سال 1993، چنین سیستمی یک کار "آموزش بسیار عمیق" را حل کرد که به بیش از 1000 لایه بعدی در یک RNN نیاز داشت که در زمان باز شده بود. 
RNN های مرتبه دوم از وزن های مرتبه بالاتر                                                 w                                                                            i                 j                 k                                                                 {\displaystyle {\displaystyle w{}_{ijk}}}     به جای وزنه های استاندارد                                                 w                                                                            i                 j                                                                 {\displaystyle {\displaystyle w{}_{ij}}}     استفاده می کنند، و ایالت ها می توانند یک محصول باشند. این امکان نگاشت مستقیم به یک ماشین حالت محدود را هم در آموزش، هم در پایداری و هم در نمایش می دهد. حافظه کوتاه‌مدت بلندمدت نمونه‌ای از این است، اما چنین نقشه‌برداری رسمی یا اثبات پایداری ندارد.
حافظه کوتاه مدت بلند مدت (LSTM) یک سیستم یادگیری عمیق است که از مشکل ناپدید شدن گرادیان جلوگیری می کند. LSTM معمولاً توسط گیت‌های مکرر به نام «دروازه‌های فراموش» تقویت می‌شود. LSTM از ناپدید شدن یا انفجار خطاهای منتشر شده جلوگیری می کند. در عوض، خطاها می توانند از طریق تعداد نامحدودی از لایه های مجازی که در فضا باز شده اند، به عقب بروند. یعنی LSTM می‌تواند کارهایی را بیاموزد که به خاطراتی از رویدادهایی نیاز دارند که هزاران یا حتی میلیون‌ها مرحله زمانی گسسته پیش از آن اتفاق افتاده‌اند. توپولوژی‌های LSTM-مشکل خاص را می‌توان تکامل داد. LSTM حتی با تأخیرهای طولانی بین رویدادهای مهم کار می کند و می تواند سیگنال هایی را که اجزای فرکانس پایین و بالا را با هم ترکیب می کنند، مدیریت کند.
واحدهای بازگشتی دروازه‌ای (GRUs) یک مکانیسم دروازه‌ای در شبکه‌های عصبی بازگشتی هستند که در سال 2014 معرفی شدند. آنها به شکل کامل و چندین نوع ساده شده استفاده می‌شوند. عملکرد آن‌ها در مدل‌سازی موسیقی چندصدایی و مدل‌سازی سیگنال گفتار شبیه به عملکرد حافظه کوتاه‌مدت بود. آنها پارامترهای کمتری نسبت به LSTM دارند، زیرا فاقد دروازه خروجی هستند.
گرادیان نزول یک الگوریتم بهینه‌سازی تکراری مرتبه اول برای یافتن حداقل یک تابع است. در شبکه های عصبی می توان از آن برای به حداقل رساندن عبارت خطا با تغییر هر وزن متناسب با مشتق خطا نسبت به آن وزن استفاده کرد، مشروط بر اینکه توابع فعال سازی غیرخطی قابل تمایز باشند. روش های مختلفی برای انجام این کار در دهه 1980 و اوایل دهه 1990 توسط Werbos، Williams، Robinson، Schmidhuber، Hochreiter، Pearlmutter و دیگران توسعه یافت.
روش استاندارد «انتشار پس از طی زمان» یا BPTT نامیده می‌شود و یک تعمیم انتشار پس‌از برای شبکه‌های پیش‌خور است. مانند آن روش، نمونه ای از تمایز خودکار در حالت انباشت معکوس اصل حداقلی Pontryagin است. یک نوع آنلاین گران‌تر از نظر محاسباتی «آموزش مکرر بی‌درنگ» یا RTRL نامیده می‌شود، که نمونه‌ای از تمایز خودکار در حالت تجمع رو به جلو با بردارهای مماس پشته‌ای است. برخلاف BPTT، این الگوریتم در زمان محلی است اما در فضا محلی نیست.
در این زمینه، محلی در فضا به این معنی است که بردار وزن یک واحد را می توان تنها با استفاده از اطلاعات ذخیره شده در واحدهای متصل و خود واحد به روز کرد، به طوری که پیچیدگی به روز رسانی یک واحد واحد در ابعاد بردار وزن خطی باشد. محلی در زمان به این معنی است که به روز رسانی ها به طور مداوم (آنلاین) انجام می شود و فقط به آخرین مرحله زمانی بستگی دارد نه به چندین مرحله زمانی در یک افق زمانی معین مانند BPTT. به نظر می رسد شبکه های عصبی بیولوژیکی با توجه به زمان و مکان محلی هستند.
برای محاسبه بازگشتی مشتقات جزئی، RTRL دارای پیچیدگی زمانی O (تعداد پنهان x تعداد وزن‌ها) در هر مرحله زمانی برای محاسبه ماتریس‌های ژاکوبین است، در حالی که BPTT فقط O (تعداد وزن‌ها) را در هر گام زمانی با هزینه دریافت می‌کند. ذخیره سازی تمام فعالیت های رو به جلو در افق زمانی معین. یک ترکیب آنلاین بین BPTT و RTRL با پیچیدگی متوسط وجود دارد، همراه با انواعی برای زمان پیوسته.
یک مشکل عمده با نزول گرادیان برای معماری‌های استاندارد RNN این است که گرادیان‌های خطا به سرعت با اندازه فاصله زمانی بین رویدادهای مهم ناپدید می‌شوند. LSTM همراه با یک روش یادگیری ترکیبی BPTT/RTRL برای غلبه بر این مشکلات تلاش می کند. این مشکل همچنین در شبکه عصبی بازگشتی مستقل (IndRNN) با کاهش زمینه یک نورون به حالت گذشته خود حل می‌شود و سپس اطلاعات متقابل نورون را می‌توان در لایه‌های زیر کاوش کرد. خاطرات با دامنه های مختلف از جمله حافظه بلند مدت را می توان بدون مشکل از بین رفتن گرادیان و انفجار یاد گرفت.
یک رویکرد برای محاسبه اطلاعات گرادیان در RNN ها با معماری های دلخواه بر اساس نمودارهای نمودار جریان سیگنال است. از الگوریتم دسته ای BPTT بر اساس قضیه لی برای محاسبات حساسیت شبکه استفاده می کند.این توسط Wan و Beaufays پیشنهاد شد، در حالی که نسخه آنلاین سریع آن توسط Campolucci، Uncini و Piazza پیشنهاد شد.
آموزش وزن ها در یک شبکه عصبی می تواند به عنوان یک مسئله بهینه سازی جهانی غیرخطی مدل شود. یک تابع هدف می تواند برای ارزیابی تناسب یا خطای یک بردار وزنی خاص به صورت زیر تشکیل شود: ابتدا وزن ها در شبکه با توجه به بردار وزن تنظیم می شوند. بعد، شبکه در برابر توالی آموزش ارزیابی می شود. به طور معمول، اختلاف مجموع مربع بین پیش بینی ها و مقادیر هدف مشخص شده در دنباله تمرین برای نشان دادن خطای بردار وزن فعلی استفاده می شود. سپس ممکن است از تکنیک های بهینه سازی جهانی دلخواه برای به حداقل رساندن این تابع هدف استفاده شود.
در ابتدا، الگوریتم ژنتیک با وزن‌های شبکه عصبی به شیوه‌ای از پیش تعریف‌شده کدگذاری می‌شود که در آن یک ژن در کروموزوم نشان دهنده یک پیوند وزنی است. کل شبکه به صورت یک کروموزوم منفرد نمایش داده می شود. عملکرد تناسب اندام به صورت زیر ارزیابی می شود:
بسیاری از کروموزوم ها جمعیت را تشکیل می دهند. بنابراین، بسیاری از شبکه های عصبی مختلف تا زمانی که یک معیار توقف برآورده شود، تکامل می یابند. یک طرح توقف متداول این است:
معیار توقف توسط تابع تناسب ارزیابی می شود زیرا متقابل میانگین مربع خطا را از هر شبکه در طول آموزش دریافت می کند. بنابراین، هدف الگوریتم ژنتیک به حداکثر رساندن تابع تناسب، کاهش میانگین مربعات خطا است.
آنها در واقع شبکه های عصبی بازگشتی با ساختار خاصی هستند: ساختار یک زنجیره خطی. در حالی که شبکه‌های عصبی بازگشتی بر روی هر ساختار سلسله مراتبی عمل می‌کنند و نمایش‌های فرزند را در نمایش‌های والد ترکیب می‌کنند، شبکه‌های عصبی بازگشتی بر اساس پیشرفت خطی زمان عمل می‌کنند و مرحله زمانی قبلی و یک نمایش پنهان را در نمایش مرحله زمانی فعلی ترکیب می‌کنند.
به طور خاص، RNN ها می توانند به عنوان نسخه های غیرخطی پاسخ ضربه محدود و فیلترهای پاسخ ضربه نامحدود و همچنین به عنوان یک مدل اگزوژن اتورگرسیو غیرخطی (NARX) ظاهر شوند.
