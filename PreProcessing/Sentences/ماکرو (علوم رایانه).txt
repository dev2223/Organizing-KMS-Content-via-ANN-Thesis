یک ماکرو (به انگلیسی&#58; macro) در علوم رایانه یک الگو یا قاعده است که مشخص می‌کند چگونه بر اساس یک فرایند از قبل معین شده، یک ترتیب ورودی بخصوص (که معمولا ترتیبی از نویسه‌ها هستند) باید به یک ترتیب خروجی جایگزین‌شده (که آن نیز معمولا ترتیبی از نویسه‌ها می باشد) نگاشت(تناظر) یابد.
فرایندی نگاشتی که در آن «ماکروی استفاده شده» به یک «ترتیب خاص» نمونه برداری (تبدیل) می شود، به عنوان «گسترش ماکرو» شناخته می شود. امکانات نوشتن ماکرو می تواند به عنوان یک نرم افزار کاربردی یا بخشی از زبان برنامه‌نویسی فراهم شود. در حالت اول، از ماکروها برای ساخت فعالیت هایی به وسیله ی برنامه های کم تکرار‌تر استفاده می شد. در حالات دوم، آنها یک ابزار‌اند که برنامه نویس امکان استفاده مجدد از کد، یا حتی امکان طراحی زبان های خاص منظوره را می دهند.
از ماکرو برای فراهم ساختن ترتیبی از دستورالعمل های محاسباتی برای برنامه‌نویس، به صورت یک عبارت برنامه ای منفرد، استفاده می شود. استفاده از ماکروها باعث کمتر «مستعد خطر بودن» و «کم تر خسته کننده بودن» برنامه نویسی استفاده می شود. (از این جهت، به آن ها ماکرو می گویند، که یک بلاک «بزرگ» کد می تواند از یک ترتیب «کوچک» از نویسه ها گسترش بیابند). ماکرو ها اکثرا استفاده از پراسنجه های کلمه کلیدی یا موقعیتی (که مشخص می کنند که برنامه‌ی اتصال شرطی چه چیزی را تولید می کند) را مجاز می داند و از آن ها برای ساخت برنامه های کامل یا مجموعه برنامه هایی برای سیستم عامل، سکوی رایانش، یا انواع دیگر برنامه استفاده می کند. عبارت «ماکرو» از «macro instruction» گرفته شده است، و از این گسترش‌ها در گذشته در اساس برای ساخت کدهای زبان اسمبلی استفاده می شد.
ماکروهای صفحه کلید و ماکروهای ماوس اجازه می‌دهد که توالی‌های کوتاهی از عملکردهای کلیدی و ماوس برای تبدیل شدن به توالی‌های کلیدی و اقدامات ماوس دیگر، معمولاً بیشتر وقت گیر باشند. به این صورت، استفاده‌های مکرر یا دنباله‌های تکراری از عملکردهای کلیدی و حرکت‌های موس می‌تواند به صورت خودکار انجام شود. برنامه‌های دیگر برای درست کردن این ماکروها را ضبظ کنندهٔ ماکرو می‌نامند.
در طول دهه ۱۹۸۰، برنامه‌های مارکرو - اول SmartKey، سپس SuperKey, KeyWorks, Prokey-ابتدا به عنوان وسیله ای برای فرمت خودکار صفحه نمایش، سپس برای انواع کارهای ورودی کاربر بسیار محبوب بودند. این برنامه‌ها بر اساس حالت عملیاتی TSR (خاتمه و اقامت) و بر روی تمام ورودی‌های صفحه کلید اعمال می‌شود، مهم نیست که در کدام زمینه رخ داده باشد. پس از ظهور واسط کاربر - و در دسترس بودن صفحه‌کلید و ماکروهای موس در برنامه‌های کاربردی مانند پردازشگرهای کلمه و صفحات گسترده، آن‌ها تا حدی در حال از بین رفتن هستند و امکان ایجاد ماکروهای صفحه کلید را برای کاربر ایجاد می‌کند.
**ماکروهای صفحه کلید اخیراً به عنوان یک روش بهره‌برداری اقتصاد بازی‌های آنلاین نقش مهمی بازی چند نفره آنلاین (MMORPGs) زندگی می‌کنند. **با انجام یک اقدام خسته‌کننده، تکراری، اما با ریسک پایین، بازیکنی که یک ماکرو را اجرا کند می‌تواند مقدار زیادی از پول رایج یا منابع را بدست آورد. این اثر حتی زمانی بزرگ‌تر است که یک بازیکن ماکرو با استفاده از حساب‌های گوناگونبه‌طور همزمان عمل می‌کند یا حساب‌ها را برای مدت‌زمان زیادی در هر روز انجام می‌دهد. از آنجا که این پول بدون دخالت انسان تولید می‌شود، می‌تواند به‌طور چشمگیریاقتصاد این بازی را واژگون کند به همین دلیل، استفاده از ماکرو نقض TOS یا EULA اکثر MMORPGها است و مدیران MMORPGها با جنگ دائمی برای شناسایی و مجازات کاربران کلان مبارزه می‌کنند.
ماکروهای صفحه کلید و ماوس که با استفاده از ویژگی‌های کلیدی ساخته شده در برنامه ایجاد می‌شوند گاهی به نام ماکرو برنامه شناخته می‌شوند. آن‌ها با انجام دادن توالی زمانی و اجازه دادن به ثبت اعمال، ایجاد می‌شوند. یک زبان برنامه‌نویسی ماکرو، اغلب زبان اسکریپتی، با دسترسی مستقیم به ویژگی‌های برنامه ممکن است وجود داشته باشد.
ویرایشگر متن برنامه نویسان، Emacs (کوتاه شدهٔ «ویرایش ماکروها») از این ایده به نتیجه می‌رسد. در واقع بیشتر ویرایشگر از macros ساخته شده‌است.Emacs در ابتدا به عنوان یک مجموعه از ماکروها در زبان ویرایش TECO ابداع شد؛ بعدها به گویش lispمنتقل شد.
ویرایشگر متن برنامه نویسان دیگر، Vim (از نوادگان ششم)، نیز اجرای کامل ماکرو را دارد. این دستگاه می‌تواند در یک رجیستر (ماکرو) ثبت شود که چه کسی روی صفحه کلید قرار دارد و می‌تواند درست مانند VBA macros برای مایکروسافت تکرار یا ویرایش شود. Vim همچنین دارای یک زبان برنامه‌نویسی به نام Vimscript برای ایجاد ماکروها است.
ویژوال بیسیک برای برنامه‌های کاربردی (VBA) یک زبان برنامه‌نویسی است که در Microsoft Office از Office 97 از طریق Office 2019 موجود است (اگر چه در بعضی از اجزای Office قبل از Office 97 موجود بود). با این حال، عملکرد آن از زبان ماکرو شکل‌گرفته و جایگزین زبان‌های ماکرو شده‌است که در اصل در برخی از این برنامه‌ها گنجانده شده‌اند.
VBA به بسیاری از فراخوانی‌های سیستم ویندوز مایکروسافت دسترسی دارد و زمانی که اسناد بازمی‌شوند اجرا می‌شود. این موضوع نوشتن ویروس‌های کامپیوتری در VBA را نسبتا آسان میکند ، که معمولاً به عنوان ویروس‌های ماکرو شناخته می‌شوند. در اواسط تا اواخر دهه ۱۹۹۰، این نوع یکی از رایج‌ترین انواع ویروس‌های کامپیوتر شد. با این حال، در اواخر دهه ۱۹۹۰ و تا به امروز، مایکروسافت برنامه‌های خود را تعمیر و به روز کرده‌است. افزون بر این، برنامه‌های ضد ویروس فعلی فوراً چنین حملاتی را بی‌اثر می‌کنند.
یک ماکرو پارامتری یک ماکرو است که می‌تواند اشیا داده‌شده را به بسط خود وارد کند. این به ماکرو مقداری از قدرت یک تابع را می‌دهد
این باعث می‌شود رشته "PI" با "۳٫۱۴۱۵۹" جایگزین شود هر کجا که رخ دهد. این رشته همواره با این رشته جایگزین خواهد شد و ریسمان حاصل را نمی‌توان به هر نحوی تغییر داد. یک مثال از ماکروی پارامتری:
ماکروهای پارامتری یک مکانیزم مفید در سطح منبع برای توسعه گسترش درون خطی است، اما در زبان‌هایی مانند C که از جایگزینی متنی ساده استفاده می‌کنند، برخی مضرات شدید برمکانیزم‌های دیگر برای انجام توسعه در خط، مانند توابع inline دارند.
ماکروهای پارامتری در زبان‌هایی مانند lisp, PL/I و Scheme استفاده می‌شود، از طرف دیگر، بسیار قدرتمندتر هستند و قادر به تصمیم‌گیری دربارهٔ آنچه که براساس استدلالات آن‌هاتولید می‌شود، هستند. از این رو، آن‌ها می‌توانند به‌طور مؤثر برای اجرای تولید کد زمانی استفاده شوند.
زبان‌هایی مانند C و برخی از زبان‌های مونتاژ دارای سیستم‌های کلان اولیه هستند که به عنوان پیش پردازنده‌های کامپایلر یا مونتاژکننده اجرا می‌شوند. ماکرو هایپیش پردازندهٔ C با جایگزینی متنی ساده در نشانه، به جای کاراکتر کار می‌کند. **با این حال، امکانات ماکرو اسمبلرهای پیچیده‌تر، به عنوان مثال، IBM High Level Assembler (HLASM) با یک پیش پردازنده قابل اجرا نیست؛ کد مونتاژ دستورالعمل‌ها و داده‌ها با کد مونتاژ فراخوانی‌های کلان در هم آمیخته‌است. ** استفاده کلاسیک از ماکرو در سیستم تایپ کامپیوتری TeX و مشتقات آن است، که اکثر این قابلیت‌ها بر اساس ماکرو است. MacroML یک سیستم آزمایشی است که به دنبال تطبیق سیستم‌های تایپ دهی ایستا و سیستم‌های ماکرو است. Nemerle ماکروهای نحوی را تایپ کرده‌است و یکی از راه‌های کارآمد برای فکر کردن به این ماکروهای نحوی به عنوان یک محاسبه چند مرحله ای است. مثال‌های دیگر:
بعضی از زبان‌ها مانند PHP می‌توانند در متن فرمت آزاد یا کد مبدأ زبان‌های دیگر تعبیه شوند. مکانیزمی که با آن قطعات کد شناسایی می‌شود (برای مثال، که با &lt;?php و ?&gt;) شبیه به یک زبان ماکروی متنی است، اما آن‌ها بسیار قدرتمند و کاملاً برجسته هستند.
ماکروها در زبان PL / I در یک زیر مجموعه از PL / I نوشته شده‌اند: کامپایلر " دستورات پیش پردازنده " را در زمان کامپایل اجرا می‌کند و خروجی این اجرا بخشی از کد تدوین‌شده توسط آن است. توانایی استفاده از یک زبان پردازشی به عنوان زبان ماکرو، بسیار بیشتر از زبان جایگزینی متن با هزینه یک کامپایلر بزرگ‌تر و کندتر است.
چارچوب ماکروهای Frame technology's دارای نحو فرماندهی خاص خود است، اما همچنین می‌تواند حاوی متن به هر زبانی باشد. هر فریم یک جز کلی در یک سلسله مراتب از زیر مجموعه‌های تودرتو و یک روش برای ادغام خود با چارچوب‌های فرعی خود (یک فرایند بازگشتی که تضادهای یکپارچه‌سازی را به نفع زیرمجموعه‌های سطح بالاتر حل می‌کند) است. خروجی‌ها اسناد سفارشی هستند، معمولاً ماژول‌های منبع کامپایل را دارند. تکنولوژی چارچوب می‌تواند از تکثیر قطعات مشابه اما بسیار متفاوت اجتناب کند، مسئله‌ای که از زمان اختراع ماکروها، توسعه نرم‌افزار را مختل کرده‌است.
اکثر زبان‌های اسمبلی دارای امکانات ماکروی دارای رویه‌ای کم‌تر هستند، به عنوان مثال اجازه می‌دهند که یک بلوک از کد را برای بازکردن حلقه تکرار کنند؛ اما این‌ها یک نحو کاملاً متفاوت از زبان اسمبلی واقعی دارند.
سیستم‌های ماکرو-مانند پردازنده C که پیشتر توضیح داده شد که کار در سطح نشانه‌های واژگانی نمی‌توانند به‌طور قابل‌اطمینان ساختار واژگانی را حفظ کنند. سیستم‌های کلان همگانی در عوض در سطح درختان انتزاعی نحوه کار می‌کنند و ساختار واژگانی برنامه اصلی را حفظ می‌کنند. کاربرد گسترده‌ای از سیستم‌های ماکرو نحوی در زبان‌های Lisp مانند Common Lisp، Clojure، Scheme , ISLISP و Racket یافت می‌شود. این زبان‌ها به خصوص برای این سبک ماکرو به خاطر اونیفورم و نحو پرانتز (که به عنوان S-عبارات شناخته می‌شود) مناسب هستند. به‌طور خاص، رکیب نحو را راحت‌تر می‌کند تا تعیین کردن فراخوانی ماکروها را آسان‌تر کند. ماکروهای Lisp ساختار برنامه خود را با استفاده از زبان کامل موجود برای بیان چنین تغییرات تبدیل می‌کند. در حالی که ماکروهای نحوی اغلب در زبان‌های Lisp یافت می‌شوند، آن‌ها نیز در زبان‌های دیگر مانند Prolog , Dylan، Scala , Nemerle، Rust، Elixir , Nim , Haxe , و Julia در دسترس هستند. آن‌ها همچنین به عنوان پسوند شخص ثالث به جاوا اسکریپت، C # و پایتون در دسترس هستند.
قبل از این که lisp ماکروها را داشته باشد، آن‌ها به اصطلاح FEXPR، عملگرهای تابع-مانند operators که ورودی آن مقادیر محاسبه‌شده توسط آرگومان‌ها نبود، بلکه به جای اشکال نحوی آرگمان‌ها، و خروجی آن مقادیری بود که باید در محاسبات استفاده شود. به عبارت دیگر، FEXPRها در همان سطح EVAL اجرا شدند و پنجره ای را به لایه متا ارزیابی ارائه دادند. به‌طور کلی مشخص شد که این یک مدل مشکل است تا به‌طور مؤثر دلیل آن را توضیح دهد.
یک ماورای فریبنده، نوعی از ماژول برنامه‌نویسی است که به عمد برخی از فرم‌های عرضه‌شده به ماکرو را می‌گیرد که ممکن است توسط یک anaphor (با اشاره به دیگری) ارجاع داده شود. ماکروسکوپ‌های Anaphoric در ابتدا در پل Graham's در lisp ظاهر شدند و نام آن‌ها اشاره به anaphora زبانی است - استفاده از کلمات به عنوان جایگزین برای کلمات قبلی.
در اواسط دهه هشتاد، تعدادی از مقالات [۱۱] [۱۲] مفهوم توسعه ماکرو بهداشتی (syntax-rules)، یک سیستم مبتنی بر الگو را معرفی کردند که در آن محیط‌های نحوی تعریف ماکرو و استفاده ماکرو متمای زهستند، که به تعریف کننده‌های ماکرو و کاربران اجازه نمی‌دهند که در مورد تصرف غیرعمدی متغیرنگران باشند (به رغم شفافیت رفرال). ماکروهای بهداشتی برای طرح در استانداردهای R5RS، R6RS و R7RS استاندارد شده‌است. تعدادی از پیاده‌سازی‌های رقابتی با استفاده از ماکروها، مانند قواعد سینتکس، حالت نحوی، تغییر نامصریح، و بسته شدن نحوی وجود دارد. هر دو syntax-rules و syntax-case در استانداردهای Scheme استاندارد شده‌است.
اخیراً، racket مفاهیم بهداشتی ماکرو با یک " برج ارزیابان " را ترکیب کرده‌است، به طوریکه زمان توسعه معنایی یک سیستم ماکرو، زمان اجرای معمولی یک بلوک دیاگرام دیگر است و نشان داد که چگونه تجزیه و تحلیل را در یک زبان غیر پرانتز اعمال کرد.
تعدادی از زبان‌ها غیر از Scheme یا ماکروهای بهداشتی را اعمال می‌کنند یا سیستم‌های بهداشتی جزئی را اجرا می‌کنند. نمونه‌هایی از Scala، Rust، Elixir، Julia , Dylan و Nemerle هستند.
فرضیات نشان می‌دهند که این سه مقوله از استفاده قانونی اولیه ازماکروها در چنین سیستمی استفاده می‌کنند. برخی دیگر استفاده از ماکروها را مانند anaphoric macros در سیستم‌های ماکرو که غیربهداشتی هستند یا تغییر شکل غیربهداشتی را ممکن می‌سازند، پیشنهاد کرده‌اند.
تعامل بین ماکروها و دیگر ویژگی‌های زبان یک حوزه مفید از تحقیق بوده‌است. برای مثال، مؤلفه‌ها و ماژول‌ها برای برنامه‌نویسی در مقیاس بزرگ مفید هستند، امابرهمکنش ماکروها و این ساختارها باید برای استفاده آن‌ها با هم تعریف شوند. ماژول و سیستم‌های جزئی که می‌توانند با ماکروها تعامل داشته باشند برای Scheme و سایر زبان‌ها با ماکرو پیشنهاد شده‌اند. به عنوان مثال، زبان racket مفهوم یک سیستم ماکرو را به یک برج نحوی بسطمی‌دهد که در آن ماکروها را می‌توان با زبان از جمله ماکروها، با استفاده از بهداشتبرای تضمین این که لایه‌های نحوی متمایز هستند و اجازه دادن ماژول برای صادراتماکروها به حوزه‌های دیگر را می‌دهد، بسط می‌دهد.
ماکروها معمولاً برای نگاشت یک رشته کوتاه (فراخوانی ماکرو) به یک توالی طولانی‌تر از دستورالعمل‌ها مورد استفاده قرار می‌گیرند. یکی دیگر که کم‌تر متداول است، استفاده از ماکروها این است که معکوس شود: نگاشت یک توالی دستورالعمل‌ها به یک رشته ماکرو. این رویکرد توسط سیستم برنامه‌نویسی موبایل STAGE۲ اتخاذ شد، که از یک کامپایلر ماکروی ابتدایی (به نام SIMCMP)استفاده می‌کرد تا یک مجموعه دستورالعمل خاص از یک کامپیوتر داده‌شده به counterpart macros را نگاشت کند. برنامه‌های کاربردی (به‌طور خاص کامپایلرها) که در این ماکروها مستقل از دستگاه نوشته شده‌است، بدون تغییر در هر کامپیوتری که مجهز به کامپایلر ماکروی اولیه است اجرا می‌شود. اولین برنامه کاربردی که در چنین زمینه ای اجرا می‌شود، یک کامپایلر ماکرو پیچیده‌تر و قدرتمند است که در زبان ماکروی مستقل از دستگاه نوشته شده‌است. این کامپایلر ماکرو برای خودش، به روش بوت استرپ، برای تولید یک نسخه ترجمه‌شده و بسیار کارآمدتر از خودش استفاده می‌شود. مزیت این رویکرد این است که برنامه‌های پیچیده را می‌توان از یک کامپیوتر به یک کامپیوتر بسیار متفاوت با تلاش بسیار کمی (برای هر معماری ماشین هدف، فقط نوشتن یک compiler ابتدایی)منتقل کرد. ظهور زبان‌های برنامه‌نویسی مدرن، به خصوص C، که کامپایلرها در تمام رایانه‌ها در دسترس هستند، این رویکرد را بی‌فایده کرده‌است. با این وجود، این یکی از اولین نمونه از بوت استرپینگ کامپایلر بود.
در حالی که دستورالعمل‌های ماکرو را می‌توان توسط برنامه‌نویس برای هر مجموعه دستورها برنامه اسمبلر محلی تعریف کرد، معمولاً ماکروها با کتابخانه‌های ماکرو مرتبط با سیستم عملیاتی که امکان دسترسی بهتوابع سیستم‌عامل را فراهم می‌کند، مرتبط هستند. مانند:
در سیستم‌های عملیاتی قدیمی‌تر مثل آن‌هایی که در پردازنده‌های مرکزی IBM مورد استفاده قرار می‌گرفتند، عملکرد سیستم‌عامل کامل تنها برای برنامه‌های زبانی assembler در دسترس بود (مگر اینکه از subroutines زبان اسمبلی استفاده شود)، همان‌طور که دستورالعمل‌های استاندارد ماکرو معمولاً دارای همتایان دارای سطح بالا نیستند.
در اواسط دهه ۱۹۵۰، زمانی که برنامه‌نویسی مونتاژ مکرر برای نوشتن برنامه های رایانه‌های دیجیتال مورد استفاده قرار گرفت، استفاده از دستورالعمل‌های ماکرو برای دو هدف اصلی آغاز شد: کاهش مقدار کدگذاری برنامه که می‌بایست با ایجاد چندین بیانیه زبان اسمبلی از یک دستور ماکرو و اجرای استانداردهای نوشتن برنامه، نوشته شود، به عنوان مثال، تعیین فرمان‌های ورودی / خروجی به روش‌های استاندارد. دستورالعمل‌های ماکرو به‌طور مؤثر یک قدم میانی بین برنامه‌نویسی زبان اسمبلی و زبان‌های برنامه‌نویسی سطح بالا بود که بعد از آن، مثل FORTRAN و کوبول معرفی شدند.. دو مورد از اولین تأسیسات برنامه‌نویسی برای توسعه «زبان‌های ماکرو» برای تولید IBM ۷۰۵، در شرکت شیمیایی داو در دلاور و فرماندهی متریال هوایی، ballistics Missile Logistics در کالیفرنیا بود. یک دستور ماکرو که در فرمت زبان اسمبلی هدف نوشته می‌شود، توسط یک مترجم ماشینی پردازش می‌شود، که برای تولید یک یا چند دستورالعمل زبان اسمبلی در کنار برنامه assembler پردازش می‌شود که دستورالعمل زبان اسمبلی را به دستورالعمل‌های زبان ماشین ترجمه می‌کند. [۲۲]
در اواخر دهه ۱۹۵۰، زبان ماکرو توسط Macro Assemblers دنبال شد. این ترکیبی از هر دو برنامه بود که در یک برنامه برای هر دو عمل می‌کرد، که از پیشپردازنده و یک موتاژکننده تشکیل شده بود. ین به برنامه نویسان زبان اسمبلی اجازه داد تا زبان ماکروی خود را پیاده کنند و قابلیت انتقال محدود کدها را بین دو ماشین اجرا کنند که همان CPU را در سیستم‌عامل متفاوت اجرا می‌کردند، برای مثال، نسخه‌های ابتدایی MSDOS و CPM - ۸۶. کتابخانه ماکرو باید برای هر ماشین هدف نوشته شود، نه برای برنامه کلی زبان اسمبلی. توجه داشته باشید که اسمبلرهای قدرتمندتر می‌توانند از ساختارهای مونتاژ مشروط در دستورالعمل‌های ماکرو استفاده کنند که می‌توانند کدهای مختلف را روی دستگاه‌های مختلف یا سیستم عامل‌های مختلف تولید کنند و نیاز به کتابخانه‌های مختلف را کاهش دهند.
در دهه ۱۹۸۰ و اوایل دهه ۱۹۹۰، رایانه‌های رومیزی تنها در چند مگاهرتز کار می‌کردند و برنامه‌های مونتاژ زبان به‌طور معمول برای سرعت بخشیدن به برنامه‌های نوشته شده در C, Fortran, Pascal و دیگران استفاده می‌شد. این زبان‌ها در آن زمان، از کنوانسیون‌های مختلف تماس استفاده می‌کردند. **ماکروها می‌توانند برای روتین‌های رابط نوشته شده در زبان مونتاژ به قسمت اولیهٔ برنامه‌های نوشته شده در هر زبان نوشته شوند. ** باز هم، کد زبان اسمبلی اصلی همان بود، فقط کتابخانه‌های ماکرو مورد نیاز برای هرزبان مقصد نوشته می‌شدند.
در سیستم‌های عملیاتی مدرن مانند یونیکس و مشتقات آن، دسترسی به سیستم از طریق subroutines ارائه می‌شود که معمولاً توسط کتابخانه‌های پویا ارائه می‌شود. زبان‌های سطح بالا مانند C، دسترسی جامع به توابع سیستم‌عامل را ارائه می‌کنند و نیاز به برنامه‌های زبانی assembler برای این قابلیت را فراهم می‌کنند.
