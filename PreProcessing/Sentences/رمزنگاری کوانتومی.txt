رمزنگاری کوانتومی دانش استفاده از ویژگی‌های مکانیکی کوانتوم برای انجام اموری است که به رمزنگاری نیاز دارند. مزیت رمزنگاری کوانتومی در این است که به کمک آن می‌توان چند عملکرد رمزنگاری را که با روش‌های غیر کوانتومی انجام‌پذیر نیستند با موفقیت به پایان رساند. دیگر این که غیرممکن است بتوان داده‌هایی را که در وضعیت کوانتومی هستند کپی‌برداری کرد. اگر فردی تلاش کند داده‌های رمزنویسی شده را بخواند، وضعیت کوانتومی تغییر می‌کند و دسترسی به آنها میسر نمی‌شود. رمزنگاری کوانتومی فقط برای تولید و توزیع کلید استفاده می‌شود و نه برای انتقال اطلاعات. این کلید در مراحل بعدی می‌تواند با هر الگوریتم رمزگذاری یا رمزگشایی برای تبدیل پیام به رمز یا برعکس استفاده شود.
رمزنگاری کوانتومی نخستین بار توسط استیون ویزنر در اوایل دهه ۱۹۷۰ ارائه شد. در سال ۱۹۹۰ یک دانشجوی دوره دکتری دانشگاه آکسفورد به نام آرتور اکرت روش دیگری برای رمزنگاری کوانتومی ارائه داد.
رمزنگاری کوانتومی استفاده مکانیک کوانتومی به خصوص ارتباطات کوانتومی و محاسبات کوانتومی برای اجرای عملیات رمزنگاری و شکستن سیستم‌های رمزگذاری شده را توصیف می‌کند. استفاده از رمزنگاری کلاسیک (غیر کوانتومی) برای حفاظت در برابر حمله کنندگان کوانتومی نیز به عنوان رمزنگاری کوانتومی در نظر گرفته می‌شود. به این حالت رمزنگاری پست-کوانتومی می‌گویند.
بیشتر گروه‌های تحقیقاتی در سراسر جهان در حال کار برای مقاوم ساختن رمزنگاری کوانتومی در برابر انواع مختلفی از اختلالات هستند. فناوری رمزنگاری کوانتومی اکنون به لحاظ تجاری قابل بهره‌برداری است اما شک و تردیدهای زیادی در ارتباط با این موضوع وجود دارد. با این حال پدیده‌های مکانیک کوانتومی، امنیت توزیع کلید کوانتومی را تضمین می‌کند. از آن‌جا که حالات کوانتوم شکننده هستند، رهگیری کلید مشترک رمزنگاری به وسیله استراق سمع باعث تغییر خواص رفتاری ذره کوانتوم شده و در نتیجه هر گونه شنود یا سرقت اطلاعات قابل کشف و شناسایی است. پیش از این برخی بنگاه‌های دولتی و بانک‌ها از راهبرد رمزنگاری کوانتومی استفاده کرده‌اند.
رمزنگاری کوانتومی انجام عملیات گوناگون رمزگذاری را که با تبادلات کلاسیک غیرممکن است میسر می‌سازد که این یکی از مزیت‌های رمزنگاری کوانتومی است. مکانیک کوانتومی تضمین می‌کند که با اندازه‌گیری داده‌های کوانتومی، این اطلاعات از بین می‌روند از این ویژگی می‌توان برای تشخیص مداخله دشمن در یک پیغام استفاده کرد. با این وجود، اگر یک شنودگر اختلالاتی کمتر از آنچه انتظار می‌رود ایجاد کند، ممکن است اطلاعات فاش شوند.
رمزنگاری شامل سه بخش اصلی فرستنده، گیرنده و هکر است؛ هکرها قادر به رهگیری ارتباطات بدون شناسایی فرستنده و گیرنده هستند، اما در شیوه رمزنگاری کوانتومی با شناسایی هکر و از بین بردن یا تغییر دادن پیام ارسالی، از دسترسی به اطلاعات جلوگیری می‌شود. در این شرایط هر تلاش برای هک کردن و دسترسی غیرمجاز به داده‌ها با کمک سد رمزنگاری کوانتومی متوقف می‌شود. رمزنگاری کوانتومی به علت ویژگی‌های منحصربه‌فرد مانند پایداری نوری بالا، طیف نشری باریک، طیف جذبی پهن، درخشندگی نوری بالا و پایداری شیمیایی به‌طور گسترده‌ای در سال‌های اخیر توجه پژوهندگان را برای استفاده جلب کرده‌است.
رایانه‌ها در رمزنگاری پیام‌های رمزبندی شده‌ای را می‌فرستند که برای رمزگشایی نیاز به کلید دارند. اما ترفندهای رمزنگاری فعلی کاملاً ایمن نیستند و با استفاده از قدرت محاسباتی کافی و صرف وقت می‌توان آنها را هک کرد. اما در رمزنگاری کوانتومی وضع به صورت دیگری است؛ هنگامی که فوتون نور از یک نقطه به نقطه دیگر حرکت می‌کند، حرکت آن وضعیتی غیر قطعی دارد. یک ناظر نمی‌تواند سوگیری یا قطبی شدن فوتون را بدون آشفتن فوتون و تغییر دادن برآمد آن دریابد؛ بنابراین اگر رمزنگاری پیامی سری، با یک کلید کوانتومی انجام شود که در وضعیت اولیه یک فوتون رمزبندی شده‌است، در این صورت هر فرد بیرونی که سعی دارد این پیام را تفسیر کند باعث آشفتگی این ذرات و تغییر یافتن کلید خواهد شد.
رمزنگاری کوانتومی بر پایه اصل «عدم قطعیت هایزنبرگ» استوار است که می‌گوید جفت‌های به خصوصی از خواص فیزیکی یک سامانه به شکلی به هم مربوط هستند که اندازه‌گیری همزمان آن‌ها غیرممکن است و اندازه‌گیری یکی از آن‌ها از اندازه‌گیری کمیت دیگر به‌طور همزمان جلوگیری می‌کند. این اصل با توجه به این نکته است که اندازه‌گیری یک سامانه حالت آن را تغییر می‌دهد؛ بنابراین وقتی در اندازه‌گیری قطبش فوتون جهت اندازه‌گیری خاصی را انتخاب می‌کنیم، این انتخاب تمامی اندازه‌گیری‌های بعدی را تحت تأثیر قرار می‌دهد چون قطبش را عوض می‌کند. اصل عدم قطعیت هایزنبرگ باعث می‌شود دقت تعیین همزمان موقعیت و مقدار جنبش آنی (تکانه) یک ذره کوانتوم محدود شود. با وجود این، می‌توان از این موضوع برای انتقال امن اطلاعات استفاده کرد. رمزنگاری کوانتومی همچون همتای کلاسیک خود نیاز به یک کلید مشترک (متقارن) برای رمزگذاری و رمزگشایی پیام‌ها دارد.
نمونه‌هایی از رمزنگاری کوانتومی استفاده از ارتباطات کوانتومی برای رد و بدل کردن مخفیانه کلید (توزیع کلید کوانتومی) یا استفاده از رایانه‌های کوانتومی برای شکستن انواع گوناگون کلیدهای عمومی و امضاهای دیجیتال می‌باشد. (به عنوان مثال سامانه‌های آر اس ای و الجمل).
مسلماً بهترین کاربرد شناخته شده از رمزنگاری کوانتومی توزیع کلید کوانتومی است. توزیع کلید کوانتومی فرایند استفاده از تبادل کوانتومی را برای ایجاد یک کلید مشترک میان دو نفر (که معمولاً آلیس و باب نامیده می‌شوند) بدون آنکه نفر سوم (ایو) هیچ اطلاعی از کلید به دست آورد را توصیف می‌کند. (حتی در صورتی که بتواند تمام مکالمات بین این دو نفر را شنود نماید) برای رسیدن به این هدف آلیس قبل از فرستادن اطلاعات به باب آن‌ها را به بیت‌های کوانتومی تبدیل می‌کند. در این حالت اگر ایو تلاش کند این بیت‌ها را بخواند، پیغام‌ها مخدوش شده و آلیس و باب متوجه مداخله وی می‌شوند.
توزیع کلید کوانتومی بدون تحمیل هر گونه فرضیات محاسباتی امکان‌پذیر است. (فرضیاتی که بیان می‌کنند بعضی از مسائل محاسباتی مانند تجزیه اعداد بزرگ زمان بسیار طولانی را روی کامپیوتر صرف می‌کنند). توزیع کلید کوانتومی دارای امنیت بدون قید و شرط است. تنها فرضیات پایدار ماندن قوانین مکانیک کوانتومی و وجود یک کانال شناسایی میان آلیس و باب است. داشتن یک کانال شناسایی امن به این معنا است که ایو نتواند خود را به جای آلیس یا باب معرفی نماید زیرا در غیر این صورت، حمله مردی در میان امکان‌پذیر می‌شود. در حال حاضر توزیع کلید کوانتومی تنها نمونه عملی از رمز نگاری کوانتومی می‌باشد.
بعد از ابداع توزیع کلید کوانتومی و امنیت بدون قید و شرط، محققان تلاش کردند تا رمز نگاری با امنیت بی‌قید و شرط را توسعه دهند. یکی از این موارد تعهد (commitment) بود. این طرح این گونه عمل می‌کند که آلیس یک مقدار را به گونه‌ای تعیین می‌کند که دیگر نمی‌تواند آن را تغییر دهد. در این صورت تا زمانی که آلیس مقدار را فاش نکند، باب نمی‌تواند هیچ اطلاعی از آن به دست آورد. این گونه طرح‌های تعهد معمولاً در پروتکل رمز نگاری استفاده می‌شود. این طرح‌ها در تنظیمات کوانتومی بسیار مورد استفاده هستند. Crépeau و Kilian نشان دادند که توسط یک تعهد و کانال کوانتومی، می‌توان یک پروتکل با امنیت بی‌قید و شرط برای اجرای انتقال بدون حافظه کوانتومی ساخت. از طرفی دیگر، Kilian نشان داد که انتقال بدون حافظه کوانتومی می‌تواند تقریباً هر نوع محاسبات توزیع شده را به روشی امن اجرا کند. این توزیع محاسبات چند طرفه امن نامیده می‌شود. توجه داشته باشید که این مطلب اندکی غیردقیق است. نتیجه به دست آمده توسط Crépeau و Kilian مستقیماً بیانگر این موضوع نیست که با داشتن یک تعهد و یک کانال کوانتومی می‌توانیم محاسبات چند طرفه امن داشته باشیم. این امر به این دلیل است که نتیجه به دست آماده "composibility" را تضمین نمی‌کنند. به عبارت دیگر، زمانی که آن‌ها را به هم متصل کنیم، یکی از آن‌ها ممکن است امنیت خود را از دست بدهد. تحقیقات بیشتر نشان داد که چگونه می‌توان از composibility در این زمینه اطمینان حاصل پیدا کرد.
پروتکل‌های تعهد کوانتومی اولیه دارای نقص بودند. Mayers نشان داد که تعهد کوانتومی با امنیت بدون قید و شرط غیرممکن است زیرا یک حمله‌کننده با ابزار محاسباتی نا محدود می‌تواند هر پروتکل تعهد کوانتومی را بشکند. با این وجود، نتیجه به دست آمده توسط مایرز احتمال ساخت پروتکل تعهد کوانتومی را با فرضیاتی ضعیفتر از فرضیات مورد نیاز برای پروتکل‌های تعهد که از ارتباطت کوانتومی استفاده نمی‌کنند غیرممکن نمی‌سازد. مدل ذخیره‌سازی محدود کوانتومی ارائه شده در پایین، نمونه‌ای از یک شرط است که در آن ارتباط کوانتومی می‌تواند برای ساخت پروتکل‌های تعهد استفاده شوند.
یکی از راه‌های ساخت تعهد کوانتومی با امنیت بی‌قید و شرط و پروتکل‌های انتقال بدون حافظه کوانتومی استفاده از مدل ذخیره‌ساز محدود کوانتمی همراه با پارازیت (BQSM) است. در این مدل فرض می‌کنیم مقدار اطلاعات کوانتومی که دشمن می‌تواند ذخیره کند، مقدار ثابت و مشخص Qاست. هر چند ما هیچ محدودیتی برای مقدار اطلاعاتی که دشمن می‌تواند در حالت کلاسیک (غیر کوانتومی) ذخیره می‌کند نداریم. در مدل ذخیره‌ساز محدود کوانتمی همراه با پارازیت می‌توان پروتکل‌های تعهد و انتقال بدون حافظه کوانتومی ساخت. اساس این ایده چنین است: طرفین پروتکل بیشتراز Q کیوبیت رد و بدل می‌کنند. از آن جایی که حتی یک طرف متقلب نمی‌تواند تمام این اطلاعات را ذخیره کند (زیرا حافظه کوانتومی دشمن حداکثر Q کیوبیت است)، قسمت اعظمی از اطلاعات باید اندازه‌گیری یا حذف شود. اجبار طرفین متقلب به اندازه‌گیری قسمت اعظمی از اطلاعات، غیرممکن بودن این عمل طبق نظریه Mayers را رد می‌کند. حال تعهد و پروتکل‌های انتقال بدون حافظه کوانتومی می‌توانند اجرا شوند. در پروتکل‌های مدل ذخیره‌ساز محدود کوانتومی همراه با پارازیت مطرح شده توسط Damgard, Fehr, Salvail و Schaffnerفرض می‌شود که طرفین راستگو هیچ اطلاعات کوانتومی را ذخیره نمی‌کنند. در این پروتکل از تکنیک‌های مشابه در توزیع کلید کوانتومی استفاده می‌کنیم. بنابرین این پروتکل‌ها حداقل در تئوری با اصول فناوری امروزه در نظر گرفته می‌شود. پیچیدگی ارتباطی یک مقدار ثابت بزرگتر از Q می‌باشد. از فواید مدل ذخیره‌ساز محدود کوانتومی همراه با پارازیت واقع بینانه بودن این فرض که حافظه کوانتومی دشمن محدود است را می‌توان نام برد. با تکنولوژی امروز ذخیره کردن حتی یک کیوبیت در زمانی به اندازه کافی طولانی نیز مشکل است. (معنی زمان به اندازه کافی طولانی به جزئیات پروتکل بستگی دارد. با معرفی یک مکث مصنوعی در پروتکل، مقدار زمانی که دشمن نیاز دارد تا اطلاعات کوانتومی را ذخیره کند می‌تواند طولانی در نظر گرفته شود) یک نمونه گسترده‌تر از مدل ذخیره‌ساز محدود کوانتومی همراه با پارازیت مدل ذخیره‌سازی همراه با پارازیت مطرح شده توسط Wehner, Schaffner و Terhal می‌باشد. در این مدل به جای در نظر گرفتن یک کران بالا برای اندازه حافظه کوانتومی دشمن، دشمن می‌تواند از ابزار ذخیره‌سازی کوانتومی ناقص با اندازه دلخواه استفاده کند. سطح نقص به وسیله کانال‌های کوانتومی مختلل مدل‌سازی می‌شود. با داشتن سطح اختلال لازم، اصول اولیه مانند مدل ذخیره‌ساز محدود کوانتومی همراه با پارازیت به دست می‌آید. همین‌طور مدل ذخیره‌ساز محدود کوانتومی همراه با پارازیت یک حالت خاص از مدل ذخیره‌سازی همراه با پارازیت را تشکیل می‌دهد. در تنظیمات کلاسیک، اگر یک محدوده برای مقدار اطلاعاتی که دشمن می‌تواند ذخیره کند در نظر بگیریم، نتایجی مشابه به دست می‌آید. اما در این مدل طرفین راستگو نیز باید از مقدار زیادی حافظه استفاده کنند (ریشه دوم محدوده حافظه استفاده شده توسط دشمن). به همین دلیل این پروتکل‌ها برای حافظ‌های واقعیی عملی نیستند. در نظر داشته باشید که با فناوری امروزه، دشمن می‌تواند با هزینه‌ای ناچیز مقدار زیادی اطلاعات کلاسیک را روی دیسک ذخیره کند.
استفاده از موقعیت جغرافیایی یک طرف و credential از اهداف رمز نگاری کوانتومی وابسته به مکان است. برای مثل، یک شخص می‌خواهد یک پیغام را به شخص دیگری در یک موقعیت مشخص برساند و اطمینان داشته باشد که تنها در صورتی گیرنده می‌تواند پیغام را بخواند که در آن مکان مشخص قرار داشته باشد. در عملیات تأیید موقعیت، آلیس می‌خواهد تصدیق دهنده‌های راستگو را قانع کند که در مکان مورد نظر قرار گرفته‌است.Chandran نشان داد که تأیید موقعیت با استفاده از پروتکل‌های کلاسیک در مقابل دشمنان غیرممکن است زیرا دشمنان می‌توانند تمام مکان‌ها بجز مکان ادعا شده را کنترل کنند. اگر دشمنان محدودیت‌های مختلفی داشته باشند، اجرای طرح‌هایی ممکن می‌شود. طرح‌های اولی کوانتومی بر پایه موقعیت تحت اسم quantum tagging توسط Kent در سال ۲۰۰۲ بررسی شدند. حق ثبت اختراع در سال ۲۰۰۶ اعطا شد اما نتایج آن در مجلات علمی تا سال ۲۰۱۰ چاپ نشدند. بعد از اینکه پروتکل‌های کوانتومی دیگری برای تأیید موقعیت در سال ۲۰۱۰ پیشنهاد شد، Buhraman et al یک نتیجه کلی مبتنی بر غیرممکن این طرح‌ها را نشان داد: با استفاده از مقدار بسیار زیادی در هم تنیدگی کوانتومی، دشمنان تبانی گر همیشه می‌توانند طوری به تصدیق دهندگانشان بدهند که گویی در مکان مشخص شده قرار دارند. این نتیجه مانع احتمال طرح‌های قابل استفاده در مدل ذخیره‌ساز محدود کوانتومی همراه با پارازیت نمی‌شود.
رایانه‌های کوانتومی می‌توانند به یک واقعیت فنی تبدیل شوند. بنابرین آموختن طرح‌های رمز نگاری در برابر دشمنان با دست رسی به کامپیوترهای کوانتومی ضروری است. به مطالعه این طرح‌ها معمولاً رمز نگاری پست-کوانتومی گفته می‌شود. نیاز به رمز نگاری پست-کوانتومی از آنجا پدید می‌آید که بسیاری از رمز گذاری‌های معروف و طرح‌های امضا می‌توانند توسط الگوریتم تجزیه Shor و محاسبه لگاریتم‌های گسسته روی یک کامپیوتر کوانتومی شکسته شوند. مثل‌هایی از این تدابیر که با دانش امروزی در مقابل دشمنان با ابزارهای کوانتومی محفوظند عبارتند از: McEliece و تدابیر lattice-based. پژوهش‌هایی دربارهٔ چگونگی تغییر تکنیک‌های رمز نگاری موجود برای مقابل دشمنان با ابزارهای کوانتومی وجود دارد. برای مثل، زمانی که سیستم‌های اثبات دانایی صفر را که در برابر دشمنان با ابزارهای کوانتومی توسعه می‌دهیم، از تکنیک‌های جدید باید استفاده شود. در تنظیمات کلاسیک، بررسی سیستم‌های اثبات دانایی صفر معمولاً شامل rewinding می‌باشد. در این تنظیمات کپی کردن حالت‌های داخلی دشمن ضروری است. در تنظیمات کوانتومی، کپی کردن یک حالت همیشه امکان‌پذیر نیست بنابرین باید از انواع گوناگون تکنیک rewinding استفاده شود.
اولین پروتکل رمزنگاری کوانتومی (BB84) BB84 نخستین طرح مورد مطالعه و عملی در رمز نگاری کوانتومی بود. این پروتکل توسط Charles Bennet و Gilles Brassard طراحی شد و در سال ۱۹۸۴ در مقاله آنها شرح داده شد.
این طرح از انتقال تک فوتون‌های قطبیده شده (به عنوان حالت‌های کوانتومی) استفاده می‌کند. فوتون‌ها می‌توانند به چهار جهت قطبی شوند که این چهار جهت در دو گروه پایه غیر متعامد دسته‌بندی می‌شوند. (هر فوتون شامل یک بیت اطلاعات است)
پایه                          &#x2A01;                 {\displaystyle \bigoplus }    برای قطبش °۰ و °۹۰ در نظر گرفته می‌شود. این پایه‌ها را به صورت                                    |                  0         &#x27E9;                 {\displaystyle |0\rangle }    و                                    |                  1         &#x27E9;                 {\displaystyle |1\rangle }     نمایش می‌دهیم. پس به‌طور خلاصه داریم:                         &#x2A01;         =         {                    |                  0         &#x27E9;         ,                    |                  1         &#x27E9;         }                 {\displaystyle \bigoplus =\{|0\rangle ,|1\rangle \}}    . این بدان معناست که فوتونی که در این پایه قطبیده شده در زاویه °۰ به معنای کد ۰ است و در زاویه °۹۰ به معنای کد ۱.
پایه                          &#x2A02;                 {\displaystyle \bigotimes }      برای قطبش °۱۳۵و °۴۵ در نظر گرفته می‌شود. این پایه‌ها را به‌صورت                                    |                  +         &#x27E9;         ,                    |                  &#x2212;         &#x27E9;                 {\displaystyle |+\rangle ,|-\rangle }    نمایش می‌دهیم که در آن:
                        &#x2223;         +         &#x27E9;                 {\displaystyle \mid +\rangle }    =                                                2                                     {\displaystyle {\sqrt {2}}}    /(                                   |                  0         &#x27E9;         +                    |                  1         &#x27E9;                 {\displaystyle |0\rangle +|1\rangle }    )
                        &#x2223;         &#x2212;         &#x27E9;                 {\displaystyle \mid -\rangle }    =                                                2                                     {\displaystyle {\sqrt {2}}}    /(                                   |                  1         &#x27E9;         &#x2212;                    |                  0         &#x27E9;                 {\displaystyle |1\rangle -|0\rangle }    )
و داریم:                          &#x2A02;                 {\displaystyle \bigotimes }    = {                        &#x2223;         +         &#x27E9;                 {\displaystyle \mid +\rangle }    ,                        &#x2223;         &#x2212;         &#x27E9;                 {\displaystyle \mid -\rangle }    }
که این به این معناست که فوتونی که در این پایه قطبیده شده، چه در زاویه °۴۵ و چه در زاویه °۱۳۵ با احتمال ۵۰٪ بمعنای کد ۱ و به احتمال ۵۰٪ بمعنای کد ۰ است.
فرض کنیم دو شخص باب و آلیس دو طرف ارتباط هستند و آلیس قرار است پیامی را برای باب بفرستد. آلیس باید انتخاب کند که چه بیتی را با استفاده از چه قطبشگری برای باب ارسال کند. اگر او همیشه مثلاً برای ۱ از قطبش عمودی و برای ۰ از قطبش افقی استفاده کند، به زودی هر کسی غیر از باب و آلیس نحوهٔ ارسال او را می‌فهمد. (می‌دانیم که چه باب و چه هر کس دیگری بخواهد بیت ارسالی توسط آلیس را بخواند باید از قطبشگر استفاده کند. پس در این صورت برای خواندن بیت‌ها قطبشگر خود را افقی بگیرد و طبق قرارداد آلیس اگر صفحه خاموش شد یعنی آلیس فوتون با قطبش عمودی فرستاده‌است. پس ۱و در غیر این صورت ۰ را ثبت می‌کند) پس به راحتی می‌تواند بیت‌های ارسالی توسط آلیس را دریافت کرده و همان‌ها را برای باب ارسال کند به گونه‌ای که آنها متوجه وجود نفر سوم نشوند. پس کاری که آلیس انجام می‌دهد این است که به‌طور تصادفی انتخاب می‌کند که ۰ بفرستد یا ۱ و از پایه                         &#x2A02;                 {\displaystyle \bigotimes }     استفاده کند یا                         &#x2A01;                 {\displaystyle \bigoplus }    . چون آلیس به‌طور تصادفی این فوتون‌های قطبیده را ارسال می‌کند پس باب نمی‌داند که قطبشگر آلیس چه بوده‌است. پس او هم برای دریافت فوتون‌های ارسالی به‌طور تصادفی قطبشگر انتخاب می‌کند. پس از ارسال همه بیت‌ها، آنها از طریق یک کانال کلاسیک (مثلا تلفن) به هم می‌گویند که از چه قطبشگری برای کدام ارسال استفاده کرده‌اند. چون شرایط هر دو قطبشگر برابر است، پس به‌طور متوسط ۵۰٪ مواقع آلیس و باب قطبشگر یکسان و در۵۰٪ مواقع قطبشگر متفاوت داشته‌اند. پس هر دوی آنها داده‌های ثبت شده مربوط به قطبشگرهای متفاوت را دور می‌ریزند. برای مثال اگر در ابتدا آلیس ۴n بیت ارسال کرده باشد، پس از حذف آن داده‌ها کلید آنها ۲n بیت خواهد داشت. به این بیت‌ها کلید خام می‌گوییم. حال تمام بیت‌های ثبت شده توسط باب و آلیس یکسان است مگر اینکه یک نفر در حال استراق سمع باشد (که او را «ایو» می‌نامیم)، یا اینکه کانال نویز داشته باشد. ما کانال بدون نویز را بررسی می‌کنیم.
برای تشخیص وجود ایو در مسیر ارتباط، آلیس n بیت را از ۲n بیتی که در دست دارد انتخاب می‌کند و از طریق یک کانال کلاسیک برای باب می‌فرستد. سپس باب آنها را با اطلاعاتی که خودش ثبت کرده‌است مقایسه می‌کند. چون کانال بدون نویز است پس هر تفاوتی در اطلاعات نشان دهندهٔ وجود ایو است. باب بعد از تشخیص وجود ایو تعداد بیت‌های متفاوت در آن n بیت را می‌شمرد و تعداد آن را به آلیس هم اعلام می‌کند. اگر این تعداد یک مقدار قابل قبولی باشد (از یک مقدار مشخص کمتر باشد)، n بیت آشکارشده دور ریخته می‌شود و n بیت باقی مانده به عنوان کلید مخفی مورد استفاده قرار می‌گیرد. همچنین اگر از مقدار مشخصی بیشتر باشد، عملیات متوقف شده و دوباره از اول انجام می‌گردد. چرا که اگر در بیت‌های آشکارشده مقدار زیادی تفاوت وجود داشته باشد، پس می‌توان نتیجه گرفت در بیت‌های باقی‌مانده هم همین تعداد بیت متفاوت وجود دارد پس اطلاعاتی که باب از کلید خواهد داشت، کمتر از میزان قابل قبول خواهد بود. اگر کلید تأیید شود، در مرحله بعد آلیس و باب برای اصلاح خطاها و کاهش اطلاعات ایو از کلید، از الگوریتمی کلاسیک استفاده می‌کنند. که این فرایند، تقویت حریم خصوصی نامیده می‌شود.
آلیس می‌تواند از ساده‌ترین پروتکل اصلاح خطاها (error correction) استفاده کند. به‌طوری که به‌صورت رندوم یک جفت بیت را انتخاب می‌کند و مقدار XOR آن‌ها را اعلام می‌کند (عملگر XOR، دو الگوی بیتی با طول یکسان دریافت کرده و یک عملیات بر روی بیت‌های متناظر انجام می‌دهد. نتیجه وقتی ۱ است که اگر فقط اولین بیت یا فقط دومین بیت ۱ باشد. اما اگر هر دو بیت ۰ یا هر دو بیت ۱ باشند، نتیجه ۱ است). اگر باب برای بیت‌های متناظر مقدار XOR یکسانی با آلیس داشت، برای آلیس «قبول» و اگر غیر از این بود، «رد» را ارسال می‌کند. در حالت اول آلیس و باب بیت اول از جفت بیت‌ها را نگه می‌دارند و بیت دوم را حذف می‌کنند. در حالت دوم هر دو بیت را حذف می‌کنند. البته در واقع الگوریتمهای پیچیده‌تر و کارآمدتری استفاده می‌شوند.
پس از اصلاح خطاها، آلیس و باب باید میزان اطلاعات ایو را با استفاده از یک پروتکل کاهش دهند. این کار می‌تواند به این صورت انجام شود که مانند قبل آلیس یک جفت بیت تصادفی انتخاب و مقدار XOR آن را محاسبه می‌کند. اما این بار مقدار XOR آنها را اعلام نمی‌کند بلکه می‌گوید کدام بیت‌ها را انتخاب کرده‌است (برای مثال بیت شماره ۱۱۵ و ۱۴۷). سپس آلیس و باب بیت‌های انتخاب شده را با مقدار XOR آنها جابجا می‌کنند. در این صورت اطلاعات ایو از کلید کم خواهد شد.
